{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#jelly","title":"Jelly","text":"<p>Jelly is a high-performance binary serialization format and streaming protocol for RDF knowledge graphs. Jelly has implementations for the JVM (works with Apache Jena, RDF4J, Titanium, and Neo4j) and Python (works with RDFLib).</p> <ul> <li> <p> Stream any RDF data, fast</p> <p>Jelly is blazing-fast by design, and can work with streams of triples, graphs, datasets, and more.</p> <p> Getting started</p> </li> <li> <p> JVM and Python implementations</p> <p>Fully-integrated support for Apache Jena, RDF4J, Titanium, Neo4j, and RDFLib.</p> <p> Jelly-JVM</p> <p> pyjelly</p> </li> <li> <p> End-to-end streaming</p> <p>Jelly comes with a gRPC protocol and can work with Kafka, MQTT, and others.</p> <p> User guide</p> <p> Streaming with Jelly-JVM</p> </li> <li> <p> Open specification</p> <p>Everything is open-source and well-documented to help you get started.</p> <p> Protocol specification</p> </li> </ul>"},{"location":"#quick-start","title":"\u26a1 Quick start","text":"CLI toolPythonJavaApache Jena pluginRDF4J pluginNeo4j <p><code>jelly-cli</code> is a simple tool that lets you convert RDF files to and from Jelly, validate Jelly files, and more.</p> Install scriptmiseManual download <p>For Linux, macOS, and WSL on Windows, run:</p> <pre><code>. &lt;(curl -sSfL https://w3id.org/jelly/setup-cli.sh)\njelly-cli\n</code></pre> <p>You can install <code>jelly-cli</code> on any platform (including Windows) using mise. Simply run:</p> <pre><code>mise use -g 'ubi:Jelly-RDF/cli[exe=jelly-cli]'\njelly-cli\n</code></pre> <p>You can also install <code>jelly-cli</code> manually by downloading the latest release, including a version for Windows without WSL and a platform-independent JAR file.</p> <p>See all available commands and documentation.</p> <p>Install the <code>pyjelly</code> package with support for RDFLib:</p> <pre><code>pip install pyjelly[rdflib]\n</code></pre> <p>Write an RDF graph to a Jelly file:</p> <pre><code>from rdflib import Graph\n\ng = Graph()\ng.parse(\"http://xmlns.com/foaf/spec/index.rdf\")\ng.serialize(destination=\"foaf.jelly\", format=\"jelly\")\n</code></pre> <p>Read a Jelly file:</p> <pre><code>g = Graph()\ng.parse(\"foaf.jelly\", format=\"jelly\")\n</code></pre> <p>See the full user guide and API reference.</p> <p>Other integrations (with or without RDFLib) are available, including Neo4j and NetworkX \u2013 see the Python user guide.</p> <p>Jelly-JVM is a super-fast implemention of Jelly, fully integrated with Apache Jena, RDF4J, and Titanium.</p> <p>To get started, add the following dependency to your <code>pom.xml</code>:</p> Apache JenaRDF4JTitanium pom.xml<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;eu.neverblink.jelly&lt;/groupId&gt;\n    &lt;artifactId&gt;jelly-jena&lt;/artifactId&gt;\n    &lt;version&gt;3.5.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>See the full Jena user guide.</p> pom.xml<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;eu.neverblink.jelly&lt;/groupId&gt;\n    &lt;artifactId&gt;jelly-rdf4j&lt;/artifactId&gt;\n    &lt;version&gt;3.5.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>See the full RDF4J user guide.</p> pom.xml<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;eu.neverblink.jelly&lt;/groupId&gt;\n    &lt;artifactId&gt;jelly-titanium-rdf-api&lt;/artifactId&gt;\n    &lt;version&gt;3.5.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> <p>See the full Titanium RDF API user guide.</p> <p>Quickly add Jelly support to your Apache Jena Fuseki server (5.2.0+) or other Jena-based applications:</p> <ol> <li>Download the Jelly plugin JAR (version 3.5.2).</li> <li>For Apache Jena Fuseki, place the JAR in the <code>$FUSEKI_BASE/extra/</code> directory. You may need to create this directory.</li> <li>Start Fuseki and enjoy full support in RDF loading, APIs, SPARQL, and content negotiation.</li> </ol> <p>See the full Jena plugin user guide for more details.</p> <p>Quickly add Jelly support to your RDF4J applications:</p> <ol> <li>Download the Jelly plugin JAR (version 3.5.2).</li> <li>For RDF4J SDK, place the JAR in the <code>lib/</code> directory. For other applications, add the JAR to your classpath.</li> <li>Start the application and enjoy full Jelly support.</li> </ol> <p>See the full RDF4J plugin user guide for more details.</p> <p>You can add Jelly support directly to your Neo4j Desktop or self-hosted server (Community / Enterprise Edition) using our plugin. Alternatively, you can use the rdflib-neo4j integration, which is more limited, but also works with AuraDB.</p> Plugin (Neo4j Desktop and self-hosted server)rdflib-neo4j (AuraDB) <p>Installation:</p> <ol> <li>Open the Neo4j installation folder.</li> <li>Download the neosemantics plugin <code>.jar</code> file from the neosemantics releases page and place it in the <code>plugins</code> folder. The plugin's version must be the same as Neo4j's.</li> <li>Download the Jelly-Neo4j plugin <code>.jar</code> file and place it in the <code>plugins</code> folder.</li> <li>Restart the Neo4j server.</li> </ol> <p>You may also need to configure your instance for RDF support. See the documentation of neosemantics for details.</p> <p>Usage:</p> <p>All features of the neosemantics plugin are supported. For example, to import a Jelly file into your Neo4j instance:</p> <pre><code>CALL n10s.rdf.import.fetch(\n    'https://w3id.org/riverbench/dumps-with-results/dev.jelly.gz', \n    'Jelly'\n)\n</code></pre> <p>See the full installation and usage guide.</p> <p>Install the <code>pyjelly</code> package with integration for Neo4j:</p> <pre><code>pip install pyjelly[rdflib] rdflib-neo4j\n</code></pre> <p>You can now import Jelly files into your Neo4j AuraDB or Neo4j server instance:</p> <pre><code>from rdflib import Graph\nfrom rdflib_neo4j import Neo4jStoreConfig, Neo4jStore\n\nneo4j_store = Graph(store=Neo4jStore(\n    config=Neo4jStoreConfig(\n        # add your connection details here\n    )\n))\n\nneo4j_store.parse(\"foaf.jelly\", format=\"jelly\")\n</code></pre> <p>See the full installation and user guide.</p>"},{"location":"#how-fast-is-it","title":"How fast is it?","text":"<p>Fast. Jelly was specifically designed to serialize and deserialize streams of RDF data faster than N-Triples or other binary formats, while being more compact than Turtle.</p> <p>The benchmarks below were performed on streams of RDF graphs or datasets, but Jelly is also good at handling streams of triples or quads (\"classic\" serialization). The benchmark was performed with Jelly-JVM 2.7.0 with Apache Jena 5.3.0. See: more benchmark results and details about the benchmark setup.</p> Serialization speed of a stream of RDF graphs or RDF datasets, averaged over 13 datasets (RiverBench 2.1.0 profile <code>stream-mixed-rdfstar</code>, task <code>stream-serialization-throughput</code>).* Partial results for RDF/XML and JSON-LD (some datasets not supported).More details about the benchmark. Deserialization (parsing) speed of a stream of RDF graphs or RDF datasets, averaged over 13 datasets (RiverBench 2.1.0 profile <code>stream-mixed-rdfstar</code>, task <code>stream-deserialization-throughput</code>).* Partial results for RDF/XML and JSON-LD (some datasets not supported).More details about the benchmark."},{"location":"#what-can-i-use-it-for","title":"What can I use it for?","text":"<p>Common use cases for Jelly include:</p> <ul> <li>Client-server communication \u2013 connect frontend and backend with less latency, improving user experience.</li> <li>Inter-service communication \u2013 efficiently exchange RDF data between microservices in complex backend applications.</li> <li>Database dumps and bulk loads \u2013 quickly write and read large RDF datasets, reducing storage space and time needed for database maintenance tasks.</li> <li>Streaming ingest \u2013 eliminate ingestion bottlenecks in systems processing large amounts of incoming streaming data.</li> <li>Database replication and change capture (new!) \u2013 record add/delete operations in RDF datasets with transaction support using Jelly-Patch.</li> </ul> <p>See also concrete examples of Jelly being used, along with example datasets.</p>"},{"location":"#commercial-and-community-support","title":"Commercial and community support","text":"<p>NeverBlink provides commercial support services for Jelly, including implementing custom features, system integrations, implementations for new frameworks, benchmarking, and more.</p> <p>Community support is available on the Jelly Discord chat.</p>"},{"location":"#see-also","title":"See also","text":"<ul> <li>User guide</li> <li>Performance benchmarks</li> <li>Protocol specification</li> <li>Contributing to Jelly</li> <li>Discord chat</li> <li>Code on GitHub: <ul> <li>Protocol definition</li> <li>JVM implementation</li> <li>Python implementation</li> <li>Rust implementation (experimental)</li> <li>Command-line utility (<code>jelly-cli</code>)</li> <li>Website</li> </ul> </li> <li>Licensing and citation</li> </ul> <p>The development of the Jelly protocol, its implementations, and supporting tooling was co-funded by the European Union. More details.</p> <p></p>"},{"location":"use-cases/","title":"Applications using Jelly","text":"<p>If you are using Jelly in your project, we would be glad to list it here! Please open an issue or open a pull request with the information on your use case.</p>"},{"location":"use-cases/#jelly-jvm","title":"Jelly-JVM","text":""},{"location":"use-cases/#tools-and-libraries","title":"Tools and libraries","text":"<ul> <li>jelly-cli \u2013 simple but performant command-line utility for working with Jelly files.<ul> <li>The app can be used to convert to/from Jelly, validate and debug Jelly files.</li> <li>You can find the code and released binaries on GitHub. The repository also has up-to-date installation instructions and command usage examples.</li> <li>You can also use the Jelly-RDF/setup-cli GitHub Action to quickly set up jelly-cli in your CI/CD workflows.</li> </ul> </li> <li>RMLMapper \u2013 library and CLI tool for generating knowledge graphs from semi-structured data, using RML rules.<ul> <li>RMLMapper supports Jelly as one of the output formats. You can use it to convert CSV, JSON, Excel, SQL, and other data sources into Jelly.</li> </ul> </li> <li>nanopub-java \u2013 Java library for working with nanopublications.<ul> <li>The library supports Jelly as one of the serialization formats, including processing streams of multiple nanopublications.</li> </ul> </li> </ul>"},{"location":"use-cases/#projects","title":"Projects","text":"<ul> <li>Nanopub Registry and Nanopub Query \u2013 next-gen services for distributed storage, management, and querying of nanopublications.<ul> <li>Jelly is used for communication between the services in the nanopub network. Jelly endpoints (ending with <code>.jelly</code>) are also exposed for downstream applications to consume nanopubs.</li> <li>The Registry stores nanopublications in the Jelly format and uses a Jelly transcoder to merge nanopubs on the fly into a single stream.</li> </ul> </li> <li>RiverBench benchmark suite.<ul> <li>Jelly is used as one of the serialization formats for distributing datasets in RiverBench.</li> <li>Jelly is also used for distributing the RDF metadata of benchmark datasets, tasks, and other resources.</li> <li>This is implemented in the ci-worker application \u2013 a Scala 3 program making heavy use of Jelly-JVM's streaming capabilities.</li> </ul> </li> <li>Jelly-JVM benchmark code. This code was used to produce the results seen on the performance page.</li> <li>RDF Stream Taxonomy (RDF-STaX) uses Jelly for distributing the RDF-STaX ontology and the living literature review of RDF streaming.<ul> <li>This is implemented using jelly-cli. Source code: GitHub.</li> </ul> </li> </ul>"},{"location":"use-cases/#example-datasets-in-the-jelly-format","title":"Example datasets in the Jelly format","text":"<p>Below listed are some example datasets available in the Jelly format. All of these are in the delimited format. The licenses for these datasets are specified on the linked documentation pages.</p> <ul> <li> <p>Large datasets (millions of triples/quads):</p> <ul> <li> ASSIST-IoT weather measurements (documentation) \u2013 80 million triples.</li> <li> 5 million nanopublications (documentation) \u2013 171 million quads.</li> <li> RDF-star annotated facts from YAGO (documentation) \u2013 2 million triples.</li> </ul> </li> <li> <p>Small datasets:</p> <ul> <li> RDF-STaX ontology (documentation).</li> <li> RiverBench suite metadata (documentation) \u2013 RiverBench also includes metadata in Jelly for benchmark tasks, datasets, and more.</li> </ul> </li> </ul> <p>You can find some more interesting datasets in the Jelly format on the RiverBench website.</p>"},{"location":"use-cases/#commercial-support","title":"Commercial support","text":"<p>NeverBlink provides commercial support services for Jelly, including implementing custom features, system integrations, implementations for new languages, benchmarking, and more.</p>"},{"location":"use-cases/#see-also","title":"See also","text":"<ul> <li>User guide</li> <li>Licensing and citation</li> </ul>"},{"location":"user-guide/","title":"Jelly user guide","text":"<p>To use Jelly, pick an implementation that matches your tech stack:</p> <ul> <li>Jelly-JVM \u2013 written in Java, integrated with Apache Jena, RDF4J, Titanium, and Neo4j.</li> <li>pyjelly \u2013 written in Python, integrated with RDFLib. Can also be used without RDFLib.</li> <li>jelly_rs (experimental) \u2013 written in Rust, integrated with Sophia.</li> <li>jelly-cli \u2013 command-line tool, works on Windows, macOS, and Linux.</li> </ul> <p>You can also create your own implementation. Because Jelly is built on top of Protocol Buffers, you can generate most of the code automatically in any popular programming language.</p>"},{"location":"user-guide/#what-can-it-do","title":"What can it do?","text":"<p>Jelly is designed to be a protocol for streaming RDF knowledge graphs, but it can also be used with static RDF datasets. Jelly was designed to be fast, well-compressed, and versatile.</p> <ul> <li>Jelly can work with any RDF knowledge graph data, including RDF 1.1, RDF-star, and generalized RDF.</li> <li>Jelly can be used to represent streams of triples, quads, graphs, or datasets.</li> <li>Jelly can also be used to represent a single graph or dataset.</li> <li>Jelly-Patch can be used to record changes to RDF datasets, including add/delete operations and transactions.</li> <li>Jelly can be used for streaming data over the network (e.g., with MQTT, Kafka, gRPC), but also for working with flat files.</li> <li>Jelly can compress RDF data on the fly, without having to know the data in advance.</li> <li>Jelly is super-fast and lightweight, scaling down to IoT and up to high-performance servers.</li> </ul>"},{"location":"user-guide/#quick-start","title":"Quick start","text":""},{"location":"user-guide/#cli-tool","title":"CLI tool","text":"<p>The easiest way to do something with Jelly is with the <code>jelly-cli</code> command line tool.</p> <p>For Linux, macOS, and WSL on Windows, install it with the following command:</p> <pre><code>. &lt;(curl -sSfL https://w3id.org/jelly/setup-cli.sh)\njelly-cli\n</code></pre> <p>You can also install <code>jelly-cli</code> manually by downloading the latest release, including a version for Windows without WSL and a platform-independent JAR file.</p> <ul> <li>Run <code>jelly-cli rdf to-jelly some-rdf-file.ttl &gt; output.jelly</code> to convert an RDF file to Jelly.</li> <li>Run <code>jelly-cli rdf from-jelly output.jelly</code> to convert the Jelly file back to RDF.</li> <li>Run <code>jelly-cli --help</code> to see all available commands.</li> </ul> <p>You can find more information about <code>jelly-cli</code> in its README on GitHub.</p> <p>Example Jelly files</p> <p>Go check out the Use cases page where we list links to example datasets in the Jelly format.</p>"},{"location":"user-guide/#apache-jena-rdf4j-plugins","title":"Apache Jena / RDF4J plugins","text":"<p>Check out the dedicated guide for installing plugins in Jena and RDF4J. You can use them to quickly add Jelly support to, for example, Apache Jena Fuseki and load Jelly files just like any other RDF file.</p>"},{"location":"user-guide/#neo4j-plugin","title":"Neo4j plugin","text":"<p>We also have a plugin for Neo4j, extending the official neosemantics plugin. Check out installation instructions and usage guide.</p>"},{"location":"user-guide/#java-scala-programming","title":"Java &amp; Scala programming","text":"<p>Go see the Jelly-JVM getting started guide for devs. It contains a lot of examples and code snippets for using Jelly in Java and Scala, with Jena, RDF4J, and Titanium.</p>"},{"location":"user-guide/#python-programming","title":"Python programming","text":"<p>See the pyjelly getting started guide. It contains examples and code snippets for using Jelly with or without RDFLib, as well as other libraries like NetworkX.</p>"},{"location":"user-guide/#how-does-it-work-encoding","title":"How does it work \u2013 encoding","text":"<p>RDF data consists of triples (subject, predicate, object) or quads (subject, predicate, object, graph name). We will use these three triples in the N-Triples format as a running example:</p> <pre><code>&lt;https://example.org/jelly&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; _:b1 .\n&lt;https://example.org/jelly&gt; &lt;https://example.org/label&gt; \"Jelly\" .\n_:b1 &lt;https://example.org/label&gt; \"Serialization format\"@en .\n</code></pre> <p>You can read that as \"Jelly is an instance of a serialization format\".</p> <p>Jelly encodes a sequence of triples or quads as a binary stream, using efficient encoding. The first thing it does is splitting IRIs into prefixes and postfixes (we call postfixes \"names\"):</p> <ul> <li>Prefixes:<ul> <li><code>[1]: https://example.org/</code></li> <li><code>[2]: http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></li> </ul> </li> <li>Names:<ul> <li><code>[1]: jelly</code></li> <li><code>[2]: type</code></li> <li><code>[3]: label</code></li> </ul> </li> </ul> <p>They are communicated in the stream as part of a dynamically changing lookup table. If we run out of IDs, we remove old entries in the lookup to free up space. Each prefix and name is assigned a numerical ID starting with 1. We can now efficiently construct IRIs as a pair of IDs (1st ID is the prefix, the 2nd ID is the name):</p> <ul> <li><code>https://example.org/jelly</code> -&gt; <code>RdfIri(1, 1)</code></li> <li><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#type</code> -&gt; <code>RdfIri(2, 2)</code></li> <li><code>https://example.org/label</code> -&gt; <code>RdfIri(1, 3)</code></li> </ul> <p>This allows us to reuse repeating prefixes and names while saving on the serialized size. We also apply the same principle to datatype IRIs (they are not split in half, though). When we apply this across our 3 triples, we will get (in simplified form):</p> Subject Predicate Object <code>RdfIri(1, 1)</code> <code>RdfIri(2, 2)</code> <code>\"b1\"</code> <code>RdfIri(1, 1)</code> <code>RdfIri(1, 3)</code> <code>RdfLiteral(\"Jelly\")</code> <code>\"b1\"</code> <code>RdfIri(1, 3)</code> <code>RdfLiteral(\"Serialization format\", \"en\")</code> <p>Notice that we have repeated IRIs in the first and second column. Jelly can compress that, by applying a method similar to Turtle's colons and semicolons, but a bit more general. If we have two consecutive triples/quads with the exact same subject, predicate, object, or graph name, we simply... don't write the repeated term:</p> Subject Predicate Object <code>RdfIri(1, 1)</code> <code>RdfIri(2, 2)</code> <code>\"b1\"</code> (empty) <code>RdfIri(1, 3)</code> <code>RdfLiteral(\"Jelly\")</code> <code>\"b1\"</code> (empty) <code>RdfLiteral(\"Serialization format\", \"en\")</code> <p>Jelly parsers detect these missing values and automatically fill them in with values from previous rows. These empty terms take up exactly 0 bytes on the wire, which makes this method very efficient.</p> <p>Jelly also applies a delta compression scheme to prefix and name IDs. You can find the details in the spec, but the short version is that we use <code>0</code> to indicate <code>previous + 1</code> ID in the case of names, and <code>previous</code> ID in the case of prefixes. For our triples, this allows us to replace all name IDs with zeroes:</p> Subject Predicate Object <code>RdfIri(1, 0)</code> <code>RdfIri(2, 0)</code> <code>\"b1\"</code> (empty) <code>RdfIri(1, 0)</code> <code>RdfLiteral(\"Jelly\")</code> <code>\"b1\"</code> (empty) <code>RdfLiteral(\"Serialization format\", \"en\")</code> <p>The value of <code>0</code> takes up exactly zero bytes \u2013 that's the same trick as with repeated terms, allowing us to save even more space.</p> <p>Jelly's encoding scheme was designed to work in a fully streaming manner. We can compress RDF data by only looking at one triple at a time, and we use a strictly limited amount of memory for that. This allows Jelly to work with datasets of any size \u2013 billions, trillions, and beyond.</p> <p>That's the basics \u2013 see the spec for details.</p> Full translation of the example to Jelly <p>The running example was translated to a text-based readable version of Jelly with jelly-cli:</p> <pre><code>jelly-cli rdf to-jelly --opt.physical-type=triples | \\\n    jelly-cli rdf from-jelly --out-format jelly-text\n</code></pre> <p>Output:</p> <pre><code># Frame 0\nrows {\n  options {\n    physical_type: PHYSICAL_STREAM_TYPE_TRIPLES\n    rdf_star: true\n    max_name_table_size: 4000\n    max_prefix_table_size: 150\n    max_datatype_table_size: 32\n    version: 1\n  }\n}\nrows {\n  prefix {\n    value: \"https://example.org/\"\n  }\n}\nrows {\n  name {\n    value: \"jelly\"\n  }\n}\nrows {\n  prefix {\n    value: \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"\n  }\n}\nrows {\n  name {\n    value: \"type\"\n  }\n}\nrows {\n  quad {\n    s_iri {\n      prefix_id: 1\n    }\n    p_iri {\n      prefix_id: 2\n    }\n    o_bnode: \"b1\"\n    g_default_graph {\n    }\n  }\n}\nrows {\n  name {\n    value: \"label\"\n  }\n}\nrows {\n  quad {\n    p_iri {\n      prefix_id: 1\n    }\n    o_literal {\n      lex: \"Jelly\"\n    }\n  }\n}\nrows {\n  quad {\n    s_bnode: \"b1\"\n    o_literal {\n      lex: \"Serialization format\"\n      langtag: \"en\"\n    }\n  }\n}\n</code></pre>"},{"location":"user-guide/#what-jelly-does-and-does-not-compress","title":"What Jelly does and does not compress","text":"<p>Jelly is pretty good at compressing IRI-heavy RDF data, but it doesn't compress the text in the IRIs themselves. Same applies to blank node identifiers, language tags, and literal contents. If you care about small file size, you should compress your Jelly file with your compressor of choice, like gzip, bzip, or zstd. We found zstd to work particularly well in practice. While Jelly by itself can make datasets ~6x smaller (this largely depends on the dataset), with zstd compression, you can sometimes get it up to 100x.</p>"},{"location":"user-guide/#how-does-it-work-streams","title":"How does it work \u2013 streams","text":"<p>A stream is just a sequence of items. We want to only look at one element of the stream at a time \u2013 this limits memory usage and allows us to process infinitely long streams.</p> <p>The most basic kind of RDF stream is what you would see in an N-Triples or N-Quads file \u2013 after all, it's just a sequence of triples:</p> <pre><code>&lt;https://example.org/jelly&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; _:b1 .\n&lt;https://example.org/jelly&gt; &lt;https://example.org/label&gt; \"Jelly\" .\n_:b1 &lt;https://example.org/label&gt; \"Serialization format\"@en .\n</code></pre> <p>We call this a flat RDF stream. Jelly supports this kind of streams \u2013 you will find them useful in transferring large RDF files, query responses, database dumps, and so on.</p> <p>But, what if our stream contains a sequence of RDF graphs or datasets? For example, if we want to transfer the measurements of a temperature sensor, we would have:</p> <p>Graph 1:</p> <pre><code>ex:sensor ex:measuredProperty ex:temperature ;\n    ex:unit ex:Kelvin ;\n    ex:value \"280.4\"^^xsd:decimal .\n</code></pre> <p>Graph 2:</p> <pre><code>ex:sensor ex:measuredProperty ex:temperature ;\n    ex:unit ex:Kelvin ;\n    ex:value \"280.6\"^^xsd:decimal .\n</code></pre> <p>...and so on. In traditional RDF systems, you had two options. You could modify the data, wrap it in containers, or apply some other processing to make it fit into one graph. Or you could simply put each graph/dataset in a separate file. Jelly offers a simpler way, where multiple graphs or datasets can live within one file. We use frames as boundary markers:</p> <pre><code># Frame 1\nex:sensor ex:measuredProperty ex:temperature ;\n    ex:unit ex:Kelvin ;\n    ex:value \"280.4\"^^xsd:decimal .\n\n# Frame 2\nex:sensor ex:measuredProperty ex:temperature ;\n    ex:unit ex:Kelvin ;\n    ex:value \"280.6\"^^xsd:decimal .\n</code></pre> <p>We call this a grouped RDF stream. A Jelly parser can unpack this and process the frames one by one. The best part is that the compression (explained above) is applied across the entire stream. So, if an IRI appears in frame 1, and then again in frame 2, we will only have to write it only once. This is very effective for data with repeating patterns, like IoT measurements, nanopublications, encyclopedic entries, or maps (geography).</p> <p>As a summary:</p> <ul> <li>Flat RDF stream \u2013 just a sequence of triples or quads. Great for processing a single file.</li> <li>Grouped RDF stream \u2013 a sequence of graphs or datasets. Great if you have many small files.</li> </ul> <p>Jelly can record in its files whether the stream is flat or grouped, but this annotation is entirely optional, and parsers can ignore it. In fact, in both cases the physical layout of the stream is the same, only the interpretation of it changes.</p> <p>The following sections contain more details about stream types in Jelly.</p>"},{"location":"user-guide/#streams-and-stream-types-in-detail","title":"Streams and stream types in detail","text":""},{"location":"user-guide/#stream-frames","title":"Stream frames","text":"<p>All stream types use the same concept of stream frames \u2013 discrete elements into which the stream is divided. Each frame contains a number of rows, which are the actual RDF data (RDF triples, quads, etc.). Jelly does not enforce the semantics of stream frames, although it does have a mechanism to suggest to consumers and producers how should they understand the stream. Still, you can interpret the stream however you like.</p> <p>Why doesn't Jelly enforce the semantics of stream frames?</p> <p>There are many, many ways in which streams of RDF data can be used \u2013 there are different use cases, network protocols, QoS settings, ordering guarantees, stream semantics, etc. One stream is also often viewed from different perspectives by the different actors producing and consuming it. Picking and enforcing specific semantics for stream frames would hopelessly overcomplicate the protocol and make it less useful in some use cases.</p> <p>Jelly does have a system of logical stream types based on the RDF Stream Taxonomy (RDF-STaX), which can be used to suggest how the stream should be interpreted. However, these are just suggestions \u2013 you can interpret the stream however you like.</p>"},{"location":"user-guide/#stream-types","title":"Stream types","text":"<p>Jelly has the notions of physical stream types and logical stream types. The physical type tells you how Jelly sends the data on the wire, which is a technical detail. The logical type tells you how you should interpret the stream. Specifying the logical type is optional and is only a suggestion to the consumer. You can always interpret the stream however you like.</p> <p>There are three physical stream types in Jelly:</p> <ul> <li><code>TRIPLES</code>: Data is encoded using triple statements. There is no information about the graph name in this type of stream.</li> <li><code>QUADS</code>: Data is encoded using quad statements. Each quad has a graph name, which can also be the default graph.</li> <li><code>GRAPHS</code>: Data is encoded using named graphs, where the graph name can also be the default graph. Each named graph can contain multiple triples.</li> </ul> <p>Warning</p> <p>The <code>GRAPHS</code> type is a left-over from a previous version of the format and right now its usefulness is limited \u2013 you can do the exact same thing with <code>QUADS</code>, which is simpler. In new projects, we recommend using <code>QUADS</code> instead.</p> <p>As for logical stream types, they are taken directly from RDF-STaX \u2013 see the RDF-STaX website for a complete list of them. The following table summarizes which physical stream types may be used for each logical stream type. Please note that the table covers only the cases that are directly supported by the Jelly protocol specification and its official implementations.</p> RDF-STaX (logical type) / Physical type <code>TRIPLES</code> <code>QUADS</code> <code>GRAPHS</code> Graph stream Framed \u2718 \u2718 Subject graph stream Framed \u2718 \u2718 Dataset stream \u2718 Framed Framed Named graph stream \u2718 Framed Framed Timestamped named graph stream \u2718 Framed Framed Flat triple stream Continuous \u2718 \u2718 Flat quad stream \u2718 Continuous Continuous <p>The values in the table mean the following:</p> <ul> <li>Framed: Each stream frame corresponds to exactly one logical element of the stream type. For example, in a graph stream, each frame corresponds to a single RDF graph. This usage pattern is common in real-time streaming scenarios like IoT systems.</li> <li>Continuous: The stream is a continuous sequence of logical elements. For example, in a flat triple stream, the stream is just a sequence of triples.</li> <li>\u2718: The physical stream type is not directly supported for the logical stream type. However, you may still find a way to use it, depending on your use case.</li> </ul> <p>The flat logical stream types (flat RDF triple stream and flat RDF quad stream in RDF-STaX) can also be treated as a single RDF graph or RDF dataset, respectively.</p>"},{"location":"user-guide/#common-patterns-cookbook","title":"Common patterns cookbook","text":"<p>Below you will find some common patterns for using Jelly. These are just examples \u2013 you can use Jelly in many other ways. All of the presented patterns are supported in the Jelly-JVM implementation with the Reactive Streaming module.</p>"},{"location":"user-guide/#flat-rdf-triple-stream-just-a-bunch-of-triples","title":"Flat RDF triple stream \u2013 \"just a bunch of triples\"","text":"<p>Let's say you want to stream a lot of triples from A to B \u2013 maybe you're doing some kind of data migration, or you're sending data to a data lake. You don't care about the graph they belong to \u2013 you just want to send a bunch of triples.</p> <p>This means you are using logically a flat RDF triple stream. It can be physically encoded as as <code>TRIPLES</code> stream, batching the triples into frames of an arbitrary size (let's say, 1000 triples each):</p> Example (click to expand) <ul> <li>Stream frame 1<ul> <li>Stream options</li> <li>Triple 1</li> <li>Triple 2</li> <li>...</li> <li>Triple 1000</li> </ul> </li> <li>Stream frame 2<ul> <li>Triple 1001</li> <li>Triple 1002</li> <li>...</li> <li>Triple 2000</li> </ul> </li> <li>...</li> </ul> <p>You can then send these frames one-by-one over gRPC or Kafka, or write them to a file. The consumer will be able to read the triples one frame at a time, without having to know how many triples there are in total.</p>"},{"location":"user-guide/#rdf-graph-stream","title":"RDF graph stream","text":"<p>In this case we have (for example) an IoT sensor that periodically emits an RDF graph that describes what the sensor saw (something like SOSA/SSN). The graphs may be of different sizes (depending on what the sensor saw) and they can be emitted at different rates (depending on how often the sensor is triggered). We want to stream these graphs to a server that will process them in real-time with no additional latency.</p> <p>This means you are using logically an RDF graph stream. You can encode it as a <code>TRIPLES</code> stream, where the stream frames correspond to different unnamed (default) graphs:</p> Example (click to expand) <ul> <li>Stream frame 1<ul> <li>Stream options</li> <li>Triple 1 (of graph 1)</li> <li>Triple 2 (of graph 1)</li> <li>...</li> <li>Triple 134 (of graph 1)</li> </ul> </li> <li>Stream frame 2<ul> <li>Triple 1 (of graph 2)</li> <li>Triple 2 (of graph 2)</li> <li>...</li> <li>Triple 97 (of graph 2)</li> </ul> </li> <li>...</li> </ul> <p>The consumer will be able to read the graphs one frame at a time, without having to know how many graphs there are in total.</p> <p>RiverBench uses this pattern for distributing its triple streams (see example). Note that in RiverBench the stream may be equivalently considered \"just a bunch of triples\" \u2013 the serialization is the same, it only depends on the interpretation on the side of the consumer.</p>"},{"location":"user-guide/#flat-rdf-quad-stream-just-a-bunch-of-quads","title":"Flat RDF quad stream \u2013 \"just a bunch of quads\"","text":"<p>You want to stream a lot of quads \u2013 similar to the \"just a bunch of triples\" case above, but you also want to include the graph node. This is logically a flat RDF quad stream. It can be physically encoded as a <code>QUADS</code> stream, batching the quads into frames of an arbitrary size (let's say, 1000 quads each):</p> Example (click to expand) <ul> <li>Stream frame 1<ul> <li>Stream options</li> <li>Quad 1</li> <li>Quad 2</li> <li>...</li> <li>Quad 1000</li> </ul> </li> <li>Stream frame 2<ul> <li>Quad 1001</li> <li>Quad 1002</li> <li>...</li> <li>Quad 2000</li> </ul> </li> <li>...</li> </ul> <p>The mechanism is exactly the same as with a flat RDF triple stream.</p>"},{"location":"user-guide/#rdf-dataset-stream-as-quads","title":"RDF dataset stream (as <code>QUADS</code>)","text":"<p>You want to stream RDF datasets \u2013 similar to the \"a stream of graphs\" case above, but your elements are entire datasets. This is logically an RDF dataset stream, which can be physically encoded as a <code>QUADS</code> stream, where the stream frames correspond to different datasets:</p> Example (click to expand) <ul> <li>Stream frame 1<ul> <li>Stream options</li> <li>Quad 1 (of dataset 1)</li> <li>Quad 2 (of dataset 1)</li> <li>...</li> <li>Quad 454 (of dataset 1)</li> </ul> </li> <li>Stream frame 2<ul> <li>Quad 1 (of dataset 2)</li> <li>Quad 2 (of dataset 2)</li> <li>...</li> <li>Quad 323 (of dataset 2)</li> </ul> </li> <li>...</li> </ul> <p>The mechanism is exactly the same as with a triple stream of graphs.</p> <p>RiverBench uses this pattern for distributing its RDF dataset streams (see example). Note that in RiverBench the stream may be equivalently considered a flat RDF quad stream \u2013 the serialization is the same, it only depends on the interpretation on the side of the consumer.</p>"},{"location":"user-guide/#ordering-and-delivery-guarantees","title":"Ordering and delivery guarantees","text":"<p>To be able to compress RDF streams on-the-fly, Jelly requires that stream frames are kept strictly in order (see also the spec). This is because the compression algorithm updates its lookup tables dynamically over the course of the stream, and a given frame depends on the lookups defined in previous frames. If the frames are out of order, the compression may fail.</p> <p>There are use cases where it's hard to guarantee strict ordering of messages, such as IoT messaging (e.g., MQTT with QoS 0) or high-throughput streams with parallel partitions (e.g., Kafka). In these cases you may want to employ one of these strategies:</p> <ul> <li>Emit shared lookup tables at the start of the stream: If you know the vocabulary of the stream, you can emit most of the content of the lookup tables at the start of the stream, and then only update the lookup elements that vary frame-to-frame, keeping the updates local to the frame. This strategy is especially useful in IoT scenarios, where the vocabulary is usually known in advance. You don't need to modify the consumer in this case.<ul> <li>A variation of this strategy is to communicate the lookup tables over a separate channel before starting the stream. This is useful if you can't guarantee that the lookup tables will be delivered before the stream frames.</li> </ul> </li> <li>Use a \"frame ID\" to keep track of the order: If you can't guarantee the order of the frames, you can add a \"frame ID\" to each frame, which will allow the consumer to reorder the frames before processing them. This strategy is useful in high-throughput scenarios, where you can't guarantee the order of the frames. You will need to modify the consumer to reorder the frames before processing them. However, handling failures in this scenario may be complicated.</li> <li>Use partitions that are guaranteed to be in-order: If you can't guarantee the order of the frames, you can use partitions that are guaranteed to be in-order (e.g., Kafka partitions). Then, each partition should have its own set of lookups (essentially treating each partition as a separate stream in Jelly's terms). This strategy is useful in high-throughput scenarios.</li> </ul> <p>Note that Jelly by default also assumes that frames are delivered at least once. At-least-once delivery is good enough (as long as the order is kept), as lookup updates are idempotent \u2013 you may only need to de-duplicate the frames afterwards. At-most-once delivery requires you to make the frames independent of each other, such as with the IoT strategy above.</p>"},{"location":"user-guide/#delimited-vs-non-delimited-jelly","title":"Delimited vs. non-delimited Jelly","text":"<p>Protobuf messages by default are not delimited. This means that when you serialize a Protobuf message (e.g., a Jelly stream frame), the serialization does not include any information about where the message ends. This is fine when there is something else telling the parser where the message ends \u2013 for example, when you're sending the message over a gRPC, Kafka, or MQTT stream, the streaming protocol tells the parser how long the message is. However, if you wanted to write multiple stream frames to a file, you would need to add some kind of delimiter between the frames \u2013 otherwise the parser would not know where one frame ends and the next one begins.</p> <p>So, to summarize:</p> Use case Jelly variant Description Jelly gRPC streaming protocol Non-delimited The gRPC protocol tells the parser how long the message is. Streaming with Kafka, MQTT, or similar Non-delimited The streaming protocol tells the parser how long the message is. Writing to a file Delimited You need to add a delimiter between the frames. Writing to a raw network socket Delimited You need to add a delimiter between the frames. <p>The delimited variant works by adding an integer before the stream frame that specifies the length of the frame, in bytes. That's it.</p> <p>You can read more about how this works in the serialization format specification.</p>"},{"location":"user-guide/#examples","title":"Examples","text":"<ul> <li>Jelly-JVM supports both variants, but uses them in different contexts. When writing to a Java byte stream (typically a file) with Apache Jena RIOT or RDF4J Rio, the delimited variant is used. However, the RIOT/Rio integrations can parse either delimited or non-delimited Jelly data. In the gRPC protocol, the non-delimited variant is used.</li> <li>RiverBench publishes its RDF metadata and datasets as Jelly files. These files are always written using the delimited variant.</li> </ul>"},{"location":"user-guide/#implementing-jelly","title":"Implementing Jelly","text":"<p>Note</p> <p>This section is intended only for those who want to write a new Jelly implementation from scratch. It's much easier to use an existing implementation, such as the JVM implementation.</p> <p>Implementing Jelly from scratch is greatly simplified by the existing Protobuf and RDF libraries. Essentially, the only thing you'll need to do is to glue them together:</p> <ul> <li>Find a Protobuf library for your language. You can find a list of official Protobuf implementations here and a list of community-maintained implementations here.</li> <li>Use the library to generate the code for the Jelly messages (this usually involves using <code>protoc</code>). You can find the Protobuf definitions in the jelly-protobuf repository.</li> <li>Find an RDF library for your language. You can find a list of RDF libraries here.</li> <li>Implement conversions to and/or from the RDF library's data structures. You can find an example of the conversion code in the Jelly-JVM implementation (<code>core</code>, <code>jena</code>, and <code>rdf4j</code> modules).</li> <li>In the implementation follow the specification to ensure compatibility.</li> </ul> <p>That's it! You may also want to implement streaming facilities, such as Reactive Streams in Java/Scala. Implementing the gRPC publish/subscribe mechanism follows a very similar procedure \u2013 many Protobuf libraries have built-in support for gRPC with code generation.</p>"},{"location":"user-guide/#see-also","title":"See also","text":"<ul> <li>Jelly-JVM getting started guide</li> <li>pyjelly getting started guide</li> <li>Applications using Jelly</li> </ul>"},{"location":"conformance/conformance-reports-page/","title":"Conformance Reports","text":"<p>This page lists conformance testing results for all available Jelly-RDF implementations. Details of the tests themselves are provided on the conformance tests page, and guidance on producing reports can be found on the reporting conformance page.</p> <p>The information presented here includes:</p> <ul> <li>The Report table, which provides a comparative overview of test outcomes across all submitted implementations.  </li> <li>The Available reports section, which lists implementation metadata (name, version, developer, assertor, and issue date) together with compliance statistics.</li> </ul>"},{"location":"conformance/conformance-reports-page/#report-table","title":"Report table","text":""},{"location":"conformance/conformance-reports-page/#from-jelly-parse","title":"From Jelly (parse)","text":""},{"location":"conformance/conformance-reports-page/#graphs_rdf_1_1","title":"graphs_rdf_1_1","text":"TestJelly-JVM (Jena 5.3.0) 3.5.2Jelly-JVM (RDF4J) 3.5.2Jelly-JVM (Titanium) 3.5.2pyjelly (Generic API) 0.6.1pyjelly (RDFLib) 0.6.1 neg_001PASSEDPASSEDPASSEDPASSEDPASSED neg_002PASSEDPASSEDPASSEDPASSEDPASSED pos_001PASSEDPASSEDPASSEDPASSEDPASSED pos_002PASSEDPASSEDPASSEDPASSEDPASSED pos_003PASSEDPASSEDPASSEDPASSEDPASSED pos_004PASSEDPASSEDPASSEDPASSEDPASSED pos_005PASSEDPASSEDPASSEDPASSEDPASSED pos_006PASSEDPASSEDPASSEDPASSEDPASSED pos_007PASSEDPASSEDPASSEDPASSEDPASSED pos_008PASSEDPASSEDPASSEDPASSEDPASSED pos_009PASSEDPASSEDPASSEDPASSEDPASSED pos_010PASSEDPASSEDPASSEDPASSEDPASSED pos_011PASSEDPASSEDPASSEDPASSEDPASSED Percentage passed:100.0%100.0%100.0%100.0%100.0%"},{"location":"conformance/conformance-reports-page/#graphs_rdf_star","title":"graphs_rdf_star","text":"TestJelly-JVM (Jena 5.3.0) 3.5.2Jelly-JVM (RDF4J) 3.5.2Jelly-JVM (Titanium) 3.5.2pyjelly (Generic API) 0.6.1pyjelly (RDFLib) 0.6.1 neg_001PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE neg_002PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE neg_003PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_001PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_002PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_003PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_004PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_005PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_006PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_007PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE Percentage passed:100.0%0.0%0.0%100.0%0.0%"},{"location":"conformance/conformance-reports-page/#quads_rdf_1_1","title":"quads_rdf_1_1","text":"TestJelly-JVM (Jena 5.3.0) 3.5.2Jelly-JVM (RDF4J) 3.5.2Jelly-JVM (Titanium) 3.5.2pyjelly (Generic API) 0.6.1pyjelly (RDFLib) 0.6.1 neg_001PASSEDPASSEDPASSEDPASSEDPASSED neg_002PASSEDPASSEDPASSEDPASSEDPASSED neg_003PASSEDPASSEDPASSEDPASSEDPASSED pos_001PASSEDPASSEDPASSEDPASSEDPASSED pos_002PASSEDPASSEDPASSEDPASSEDPASSED pos_003PASSEDPASSEDPASSEDPASSEDPASSED pos_004PASSEDPASSEDPASSEDPASSEDPASSED pos_005PASSEDPASSEDPASSEDPASSEDPASSED pos_006PASSEDPASSEDPASSEDPASSEDPASSED pos_007PASSEDPASSEDPASSEDPASSEDPASSED pos_008PASSEDPASSEDPASSEDPASSEDPASSED Percentage passed:100.0%100.0%100.0%100.0%100.0%"},{"location":"conformance/conformance-reports-page/#quads_rdf_1_1_generalized","title":"quads_rdf_1_1_generalized","text":"TestJelly-JVM (Jena 5.3.0) 3.5.2Jelly-JVM (RDF4J) 3.5.2Jelly-JVM (Titanium) 3.5.2pyjelly (Generic API) 0.6.1pyjelly (RDFLib) 0.6.1 pos_001PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_002PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_003PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_004PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_005PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE Percentage passed:100.0%0.0%0.0%100.0%0.0%"},{"location":"conformance/conformance-reports-page/#quads_rdf_star","title":"quads_rdf_star","text":"TestJelly-JVM (Jena 5.3.0) 3.5.2Jelly-JVM (RDF4J) 3.5.2Jelly-JVM (Titanium) 3.5.2pyjelly (Generic API) 0.6.1pyjelly (RDFLib) 0.6.1 neg_001PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE neg_002PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE neg_003PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_001PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_002PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_003PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_004PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_005PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_006PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_007PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE Percentage passed:100.0%0.0%0.0%100.0%0.0%"},{"location":"conformance/conformance-reports-page/#quads_rdf_star_generalized","title":"quads_rdf_star_generalized","text":"TestJelly-JVM (Jena 5.3.0) 3.5.2Jelly-JVM (RDF4J) 3.5.2Jelly-JVM (Titanium) 3.5.2pyjelly (Generic API) 0.6.1pyjelly (RDFLib) 0.6.1 neg_001PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE neg_002PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE neg_003PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_001PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_002PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_003PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_004PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_005PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_006PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE Percentage passed:100.0%0.0%0.0%100.0%0.0%"},{"location":"conformance/conformance-reports-page/#triples_rdf_1_1","title":"triples_rdf_1_1","text":"TestJelly-JVM (Jena 5.3.0) 3.5.2Jelly-JVM (RDF4J) 3.5.2Jelly-JVM (Titanium) 3.5.2pyjelly (Generic API) 0.6.1pyjelly (RDFLib) 0.6.1 neg_001PASSEDPASSEDINAPPLICABLEPASSEDPASSED neg_002PASSEDPASSEDINAPPLICABLEPASSEDPASSED neg_003PASSEDPASSEDINAPPLICABLEPASSEDPASSED neg_005PASSEDPASSEDINAPPLICABLEPASSEDPASSED neg_006PASSEDPASSEDINAPPLICABLEPASSEDPASSED neg_007PASSEDPASSEDINAPPLICABLEPASSEDPASSED neg_008PASSEDPASSEDINAPPLICABLEPASSEDPASSED neg_010PASSEDPASSEDINAPPLICABLEPASSEDPASSED neg_012PASSEDPASSEDINAPPLICABLEPASSEDPASSED neg_013PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_001PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_002PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_003PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_004PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_005PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_006PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_007PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_008PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_009PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_011PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_012PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_013PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_014PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_015PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_016PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_017PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_018PASSEDPASSEDINAPPLICABLEPASSEDPASSED Percentage passed:100.0%100.0%0.0%100.0%100.0%"},{"location":"conformance/conformance-reports-page/#triples_rdf_1_1_generalized","title":"triples_rdf_1_1_generalized","text":"TestJelly-JVM (Jena 5.3.0) 3.5.2Jelly-JVM (RDF4J) 3.5.2Jelly-JVM (Titanium) 3.5.2pyjelly (Generic API) 0.6.1pyjelly (RDFLib) 0.6.1 pos_001PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_002PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_003PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_004PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_005PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE Percentage passed:100.0%0.0%0.0%100.0%0.0%"},{"location":"conformance/conformance-reports-page/#triples_rdf_star","title":"triples_rdf_star","text":"TestJelly-JVM (Jena 5.3.0) 3.5.2Jelly-JVM (RDF4J) 3.5.2Jelly-JVM (Titanium) 3.5.2pyjelly (Generic API) 0.6.1pyjelly (RDFLib) 0.6.1 neg_001PASSEDPASSEDINAPPLICABLEPASSEDINAPPLICABLE neg_002PASSEDPASSEDINAPPLICABLEPASSEDINAPPLICABLE neg_003PASSEDPASSEDINAPPLICABLEPASSEDINAPPLICABLE pos_001PASSEDPASSEDINAPPLICABLEPASSEDINAPPLICABLE pos_002PASSEDPASSEDINAPPLICABLEPASSEDINAPPLICABLE pos_003PASSEDPASSEDINAPPLICABLEPASSEDINAPPLICABLE pos_004PASSEDPASSEDINAPPLICABLEPASSEDINAPPLICABLE pos_005PASSEDPASSEDINAPPLICABLEPASSEDINAPPLICABLE pos_006PASSEDPASSEDINAPPLICABLEPASSEDINAPPLICABLE pos_007PASSEDPASSEDINAPPLICABLEPASSEDINAPPLICABLE pos_008PASSEDPASSEDINAPPLICABLEPASSEDINAPPLICABLE Percentage passed:100.0%100.0%0.0%100.0%0.0%"},{"location":"conformance/conformance-reports-page/#triples_rdf_star_generalized","title":"triples_rdf_star_generalized","text":"TestJelly-JVM (Jena 5.3.0) 3.5.2Jelly-JVM (RDF4J) 3.5.2Jelly-JVM (Titanium) 3.5.2pyjelly (Generic API) 0.6.1pyjelly (RDFLib) 0.6.1 neg_001PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE neg_002PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE neg_003PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_001PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_002PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_003PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_004PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_005PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_006PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE Percentage passed:100.0%0.0%0.0%100.0%0.0%"},{"location":"conformance/conformance-reports-page/#to-jelly-serialize","title":"To Jelly (serialize)","text":""},{"location":"conformance/conformance-reports-page/#graphs_rdf_1_2","title":"graphs_rdf_1_1","text":"TestJelly-JVM (Jena 5.3.0) 3.5.2Jelly-JVM (RDF4J) 3.5.2Jelly-JVM (Titanium) 3.5.2pyjelly (Generic API) 0.6.1pyjelly (RDFLib) 0.6.1 pos_001INAPPLICABLEINAPPLICABLEINAPPLICABLEPASSEDPASSED pos_002INAPPLICABLEINAPPLICABLEINAPPLICABLEPASSEDPASSED pos_003INAPPLICABLEINAPPLICABLEINAPPLICABLEPASSEDPASSED pos_004INAPPLICABLEINAPPLICABLEINAPPLICABLEPASSEDPASSED pos_005INAPPLICABLEINAPPLICABLEINAPPLICABLEPASSEDPASSED pos_006INAPPLICABLEINAPPLICABLEINAPPLICABLEPASSEDPASSED pos_007INAPPLICABLEINAPPLICABLEINAPPLICABLEPASSEDPASSED pos_008INAPPLICABLEINAPPLICABLEINAPPLICABLEPASSEDPASSED pos_009INAPPLICABLEINAPPLICABLEINAPPLICABLEPASSEDPASSED Percentage passed:0.0%0.0%0.0%100.0%100.0%"},{"location":"conformance/conformance-reports-page/#graphs_rdf_star_1","title":"graphs_rdf_star","text":"TestJelly-JVM (Jena 5.3.0) 3.5.2Jelly-JVM (RDF4J) 3.5.2Jelly-JVM (Titanium) 3.5.2pyjelly (Generic API) 0.6.1pyjelly (RDFLib) 0.6.1 pos_001INAPPLICABLEINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_002INAPPLICABLEINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_003INAPPLICABLEINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_004INAPPLICABLEINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_005INAPPLICABLEINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_006INAPPLICABLEINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_007INAPPLICABLEINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE Percentage passed:0.0%0.0%0.0%100.0%0.0%"},{"location":"conformance/conformance-reports-page/#quads_rdf_1_2","title":"quads_rdf_1_1","text":"TestJelly-JVM (Jena 5.3.0) 3.5.2Jelly-JVM (RDF4J) 3.5.2Jelly-JVM (Titanium) 3.5.2pyjelly (Generic API) 0.6.1pyjelly (RDFLib) 0.6.1 pos_001PASSEDPASSEDPASSEDPASSEDPASSED pos_002PASSEDPASSEDPASSEDPASSEDPASSED pos_003PASSEDPASSEDPASSEDPASSEDPASSED pos_004PASSEDPASSEDPASSEDPASSEDPASSED pos_005PASSEDPASSEDPASSEDPASSEDPASSED pos_006PASSEDPASSEDPASSEDPASSEDPASSED Percentage passed:100.0%100.0%100.0%100.0%100.0%"},{"location":"conformance/conformance-reports-page/#quads_rdf_1_1_generalized_1","title":"quads_rdf_1_1_generalized","text":"TestJelly-JVM (Jena 5.3.0) 3.5.2Jelly-JVM (RDF4J) 3.5.2Jelly-JVM (Titanium) 3.5.2pyjelly (Generic API) 0.6.1pyjelly (RDFLib) 0.6.1 pos_001PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_002PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_003PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_004PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_005PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE Percentage passed:100.0%0.0%0.0%100.0%0.0%"},{"location":"conformance/conformance-reports-page/#quads_rdf_star_1","title":"quads_rdf_star","text":"TestJelly-JVM (Jena 5.3.0) 3.5.2Jelly-JVM (RDF4J) 3.5.2Jelly-JVM (Titanium) 3.5.2pyjelly (Generic API) 0.6.1pyjelly (RDFLib) 0.6.1 pos_001PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_002PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_003PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_004PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_005PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_006PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_007PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE Percentage passed:100.0%0.0%0.0%100.0%0.0%"},{"location":"conformance/conformance-reports-page/#quads_rdf_star_generalized_1","title":"quads_rdf_star_generalized","text":"TestJelly-JVM (Jena 5.3.0) 3.5.2Jelly-JVM (RDF4J) 3.5.2Jelly-JVM (Titanium) 3.5.2pyjelly (Generic API) 0.6.1pyjelly (RDFLib) 0.6.1 pos_001PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_002PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_003PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_004PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_005PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_006PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE Percentage passed:100.0%0.0%0.0%100.0%0.0%"},{"location":"conformance/conformance-reports-page/#triples_rdf_1_2","title":"triples_rdf_1_1","text":"TestJelly-JVM (Jena 5.3.0) 3.5.2Jelly-JVM (RDF4J) 3.5.2Jelly-JVM (Titanium) 3.5.2pyjelly (Generic API) 0.6.1pyjelly (RDFLib) 0.6.1 neg_001PASSEDPASSEDINAPPLICABLEPASSEDPASSED neg_002PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_001PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_002PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_003PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_004PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_005PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_006PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_007PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_008PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_009PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_010PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_011PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_012PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_013PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_014PASSEDPASSEDINAPPLICABLEPASSEDFAILED pos_015PASSEDPASSEDINAPPLICABLEPASSEDPASSED pos_016PASSEDPASSEDINAPPLICABLEPASSEDPASSED Percentage passed:100.0%100.0%0.0%100.0%94.4%"},{"location":"conformance/conformance-reports-page/#triples_rdf_1_1_generalized_1","title":"triples_rdf_1_1_generalized","text":"TestJelly-JVM (Jena 5.3.0) 3.5.2Jelly-JVM (RDF4J) 3.5.2Jelly-JVM (Titanium) 3.5.2pyjelly (Generic API) 0.6.1pyjelly (RDFLib) 0.6.1 pos_001PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_002PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_003PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_004PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_005PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE Percentage passed:100.0%0.0%0.0%100.0%0.0%"},{"location":"conformance/conformance-reports-page/#triples_rdf_star_1","title":"triples_rdf_star","text":"TestJelly-JVM (Jena 5.3.0) 3.5.2Jelly-JVM (RDF4J) 3.5.2Jelly-JVM (Titanium) 3.5.2pyjelly (Generic API) 0.6.1pyjelly (RDFLib) 0.6.1 pos_001PASSEDPASSEDINAPPLICABLEPASSEDINAPPLICABLE pos_002PASSEDPASSEDINAPPLICABLEPASSEDINAPPLICABLE pos_003PASSEDPASSEDINAPPLICABLEPASSEDINAPPLICABLE pos_004PASSEDPASSEDINAPPLICABLEPASSEDINAPPLICABLE pos_005PASSEDPASSEDINAPPLICABLEPASSEDINAPPLICABLE pos_006PASSEDPASSEDINAPPLICABLEPASSEDINAPPLICABLE pos_007PASSEDPASSEDINAPPLICABLEPASSEDINAPPLICABLE pos_008PASSEDPASSEDINAPPLICABLEPASSEDINAPPLICABLE Percentage passed:100.0%100.0%0.0%100.0%0.0%"},{"location":"conformance/conformance-reports-page/#triples_rdf_star_generalized_1","title":"triples_rdf_star_generalized","text":"TestJelly-JVM (Jena 5.3.0) 3.5.2Jelly-JVM (RDF4J) 3.5.2Jelly-JVM (Titanium) 3.5.2pyjelly (Generic API) 0.6.1pyjelly (RDFLib) 0.6.1 pos_001PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_002PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_003PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_004PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_005PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE pos_006PASSEDINAPPLICABLEINAPPLICABLEPASSEDINAPPLICABLE Percentage passed:100.0%0.0%0.0%100.0%0.0%"},{"location":"conformance/conformance-reports-page/#available-reports","title":"Available reports","text":"<p>This section lists all submitted implementation reports, with metadata from DOAP/FOAF, and their compliance scores.</p>"},{"location":"conformance/conformance-reports-page/#jelly-jvm-jena-530-352","title":"Jelly-JVM (Jena 5.3.0) 3.5.2","text":"<p>Jelly-JVM integration with Jena 5.3.0</p> <ul> <li>Programming Language: Java</li> <li>Home Page: https://w3id.org/jelly/jelly-jvm</li> <li>Developer: Jelly-JVM contributors</li> <li>Assertor: Jelly-JVM integration test suite</li> <li>Test Suite Compliance: </li> <li>Report file: <code>Jelly-JVM Jena.ttl</code></li> </ul>"},{"location":"conformance/conformance-reports-page/#jelly-jvm-rdf4j-352","title":"Jelly-JVM (RDF4J) 3.5.2","text":"<p>Jelly-JVM integration with RDF4J</p> <ul> <li>Programming Language: Java</li> <li>Home Page: https://w3id.org/jelly/jelly-jvm</li> <li>Developer: Jelly-JVM contributors</li> <li>Assertor: Jelly-JVM integration test suite</li> <li>Test Suite Compliance: </li> <li>Report file: <code>Jelly-JVM RDF4J.ttl</code></li> </ul>"},{"location":"conformance/conformance-reports-page/#jelly-jvm-titanium-352","title":"Jelly-JVM (Titanium) 3.5.2","text":"<p>Jelly-JVM integration with Titanium</p> <ul> <li>Programming Language: Java</li> <li>Home Page: https://w3id.org/jelly/jelly-jvm</li> <li>Developer: Jelly-JVM contributors</li> <li>Assertor: Jelly-JVM integration test suite</li> <li>Test Suite Compliance: </li> <li>Report file: <code>Jelly-JVM Titanium.ttl</code></li> </ul>"},{"location":"conformance/conformance-reports-page/#pyjelly-generic-api-061","title":"pyjelly (Generic API) 0.6.1","text":"<p>pyjelly (Generic API)</p> <ul> <li>Programming Language: Python</li> <li>Home Page: https://w3id.org/jelly/pyjelly</li> <li>Developer: pyjelly contributors</li> <li>Assertor: pyjelly test suite</li> <li>Test Suite Compliance: </li> <li>Report file: <code>pyjelly Generic API.ttl</code></li> </ul>"},{"location":"conformance/conformance-reports-page/#pyjelly-rdflib-061","title":"pyjelly (RDFLib) 0.6.1","text":"<p>pyjelly integration with RDFLib</p> <ul> <li>Programming Language: Python</li> <li>Home Page: https://w3id.org/jelly/pyjelly</li> <li>Developer: pyjelly contributors</li> <li>Assertor: pyjelly test suite</li> <li>Test Suite Compliance: </li> <li>Report file: <code>pyjelly RDFLib.ttl</code></li> </ul>"},{"location":"conformance/reporting-conformance/","title":"Reporting conformance","text":"<p>To ensure interoperability between different Jelly implementations, it is important to verify that each system correctly follows the specification. Conformance testing provides a consistent way to demonstrate which features are implemented and how well they align with the standard. Results are recorded in a standardized format so they can be automatically aggregated, compared, and published.</p> <p>Note</p> <p>Implementations may extend Jelly with additional features, provided these extensions do not prevent the serialization from being readable by implementations that follow the requirements.</p>"},{"location":"conformance/reporting-conformance/#how-to-report-conformance","title":"How to report conformance?","text":"<p>Report results using EARL 1.0 (Evaluation and Report Language), one <code>earl:Assertion</code> per test. Run the official Jelly test manifests for the protocol version you implement; iterate each applicable entry and record its outcome.  </p> <p>What to include:</p> <ul> <li>Assertions: for every applicable test, create a <code>earl:Assertion</code> with <code>earl:test</code> (the test IRI from the manifest), <code>earl:subject</code> (your implementation), <code>earl:assertedBy</code>, <code>earl:mode</code> (usually <code>earl:automatic</code>), and <code>earl:result/earl:outcome</code> (allowed outcomes: <code>earl:passed</code>, <code>earl:failed</code>, <code>earl:inapplicable</code>, <code>earl:cantTell</code>, <code>earl:untested</code>).  </li> <li>Metadata: describe the implementation with DOAP (name, version, homepage) and the assertions with FOAF.  </li> </ul>"},{"location":"conformance/reporting-conformance/#where-to-submit-how-its-used","title":"Where to submit / how it\u2019s used","text":"<p>Submit the EARL file (in Turtle format) via pull request to this directory. Submitted EARL files are then aggregated into a human-readable table on the site.  </p> <p>Example EARL report</p> <p>An example, complete, ready-to-submit EARL report template can be found here. Replace placeholders (names, dates) and add one <code>earl:Assertion</code> per Jelly test you executed (use the exact test IRIs from the Jelly manifests).  </p> <p>Manifests:</p> <ul> <li>Test manifests are RDF lists of tests that provide names, inputs/expecteds, and status; test runners iterate these to produce EARL reports.  </li> <li>Manifests for Jelly can be found here.</li> </ul>"},{"location":"conformance/tests/","title":"Test cases \u2014 Jelly-RDF test cases","text":"<p>This page lists all protocol conformance tests used by every Jelly implementation.</p> <p>Each test entry shows: Name (category), Description (with test ID), Data (triples / quads / graphs), Input(s), and Expected output.</p> <p>Use the jump list below to navigate by category.</p> <p>Finding relevant tests: Categories indicate supported features: <code>rdf_star</code> (RDF-star), <code>generalized</code>, <code>graphs</code>, <code>quads</code>, <code>triples</code>. Skip tests from categories you do not implement.</p> <p>Running a test: Compare your output with the expected one:</p> <p><pre><code>jelly-cli rdf validate --compare-ordered=true &lt;your_output&gt; &lt;expected_output&gt;\n</code></pre> See jelly-cli.</p> <p>Run locally in Python:</p> <pre><code>pytest tests/conformance_tests/test_rdf\n</code></pre> <p>Manifests: from_jelly \u00b7 to_jelly</p>"},{"location":"conformance/tests/#summary","title":"Summary","text":"<ul> <li>All tests: 187</li> <li>From Jelly: 110 (positive: 80, negative: 30)</li> <li>To Jelly: 77 (positive: 75, negative: 2)</li> </ul>"},{"location":"conformance/tests/#from-jelly-parse","title":"From Jelly (parse)","text":""},{"location":"conformance/tests/#jump-to-category","title":"Jump to category","text":"<ul> <li>graphs_rdf_1_1</li> <li>graphs_rdf_star</li> <li>quads_rdf_1_1</li> <li>quads_rdf_1_1_generalized</li> <li>quads_rdf_star</li> <li>quads_rdf_star_generalized</li> <li>triples_rdf_1_1</li> <li>triples_rdf_1_1_generalized</li> <li>triples_rdf_star</li> <li>triples_rdf_star_generalized</li> </ul>"},{"location":"conformance/tests/#graphs_rdf_1_1","title":"graphs_rdf_1_1","text":"<p>11 positive, 0 negative</p>"},{"location":"conformance/tests/#positive","title":"Positive","text":"Name Description Data Input(s) Expected output graphs_rdf_1_1 Single frame, a set of quads with all possible graph labels: default graph, IRI, blank node. Prefix table disabled. <code>quads</code> in.jelly out_000.nq graphs_rdf_1_1 Single frame. A set of quads with a variety of terms and with the same graph label appearing twice in the frame with another graph in-between. Prefix table disabled. <code>quads</code> in.jelly out_000.nq graphs_rdf_1_1 Single frame. A set of quads, each quad repeats three (3) times in the respective graph. Prefix table disabled. <code>quads</code> in.jelly out_000.nq graphs_rdf_1_1 Three (3) frames. A mix of quads with repeated s/p/o/g terms. Prefix table disabled. <code>quads</code> in.jelly out_000.nq graphs_rdf_1_1 Three (3) frames. A mix of quads with repeated s/p/o/g terms. Prefix table enabled. <code>quads</code> in.jelly out_000.nq graphs_rdf_1_1 Three (3) frames. All frames correspond to one (1) unique graph label. Prefix table disabled. <code>quads</code> in.jelly out_000.nq graphs_rdf_1_1 Three (3) frames. Each frame corresponds to one (1) unique graph label. <code>quads</code> in.jelly out_000.nq graphs_rdf_1_1 Three (3) frames. Four (4) graphs sequentially span three (3) frames. Prefix table enabled. <code>quads</code> in.jelly out_000.nq graphs_rdf_1_1 Two (2) frames, logical stream type set to LOGICAL_STREAM_TYPE_DATASETS. <code>quads</code> in.jelly out_000.nq graphs_rdf_1_1 Two (2) frames, logical stream type set to LOGICAL_STREAM_TYPE_NAMED_GRAPHS. Prefix table disabled. <code>quads</code> in.jelly out_000.nq graphs_rdf_1_1 Two (2) frames, logical stream type set to LOGICAL_STREAM_TYPE_TIMESTAMPED_NAMED_GRAPHS. Prefix table disabled. <code>quads</code> in.jelly out_000.nq"},{"location":"conformance/tests/#graphs_rdf_star","title":"graphs_rdf_star","text":"<p>7 positive, 3 negative</p>"},{"location":"conformance/tests/#positive_1","title":"Positive","text":"Name Description Data Input(s) Expected output graphs_rdf_star Single frame with a set of quads contatining quoted triples in s/o or both in one IRI-labeled graph. Prefix table disabled. <code>quads</code> in.jelly out_000.nq graphs_rdf_star Single frame with a set of quads contatining quoted triples in s/o or both in the default and BN-/IRI-labeled graphs. Prefix table disabled. <code>quads</code> in.jelly out_000.nq graphs_rdf_star Single frame with a set of quads contatining quoted triples in s/o or both mixed with the same quoted triples as assertions in the respective default and BN-/IRI-labeled graphs. Prefix table disabled. <code>quads</code> in.jelly out_000.nq graphs_rdf_star Single frame with a set of quads with quoted triples in s/o or both mixed with the same quoted triples as assertions in the respective default and BN-/IRI-labeled graphs. Statements repeated in the\u2026 <code>quads</code> in.jelly out_000.nq graphs_rdf_star Single frame with a set of quads with quoted triples nesting level 10 in s and o in the default and BN-/IRI-labeled graphs. Predicates repeat across nested levels. Prefix table disabled. <code>quads</code> in.jelly out_000.nq graphs_rdf_star Single frame with one simple quoted triple in the default graph. Prefix table disabled. <code>quads</code> in.jelly out_000.nq graphs_rdf_star Three (3) frames with a set of quads with quoted triples. Prefix table enabled. <code>quads</code> in.jelly out_000.nq"},{"location":"conformance/tests/#negative","title":"Negative","text":"Name Description Data Input(s) Expected output graphs_rdf_star Single frame, o_triple_term is missing a p_iri on level 5 and is repeated on the previous and next nesting levels. Repeated terms are prohibited in quoted triples. Prefix table disabled. <code>graphs</code> in.jelly \u2014 graphs_rdf_star Single frame, o_triple_term is missing a s_iri. Repeated terms are prohibited in quoted triples. Prefix table disabled. <code>graphs</code> in.jelly \u2014 graphs_rdf_star Single frame, s_triple_term is empty {}. Repeated terms are prohibited in quoted triples. Prefix table disabled. <code>graphs</code> in.jelly \u2014"},{"location":"conformance/tests/#quads_rdf_1_1","title":"quads_rdf_1_1","text":"<p>8 positive, 5 negative</p>"},{"location":"conformance/tests/#positive_2","title":"Positive","text":"Name Description Data Input(s) Expected output quads_rdf_1_1 Single frame, a few basic triples in the default graph. Prefix table enabled. <code>quads</code> in.jelly out_000.nq quads_rdf_1_1 Single frame, a few quads with repeated s/p. One quad per default, named, and BN-labeled graph. Prefix table disabled. <code>quads</code> in.jelly out_000.nq quads_rdf_1_1 Single frame, a mix of quads with repeated terms in s, p, o, g. Prefix table disabled. <code>quads</code> in.jelly out_000.nq quads_rdf_1_1 Three (3) frames, a mix of quads with repeated terms across frames, including frame 2 starting from a fully repeated assertion. Prefix table disabled. <code>quads</code> in.jelly out_000.nq quads_rdf_1_1 Three (3) frames, a mix of quads with repeated terms across frames, including frame 2 starting from a fully repeated assertion. Prefix table enabled. <code>quads</code> in.jelly out_000.nq quads_rdf_1_1 Two (2) frames, logical stream type set to LOGICAL_STREAM_TYPE_DATASETS. Prefix table disabled. <code>quads</code> in.jelly out_000.nq quads_rdf_1_1 Two (2) frames, logical stream type set to LOGICAL_STREAM_TYPE_NAMED_GRAPHS. Prefix table disabled. <code>quads</code> in.jelly out_000.nq quads_rdf_1_1 Two (2) frames, logical stream type set to LOGICAL_STREAM_TYPE_TIMESTAMPED_NAMED_GRAPHS. Prefix table disabled. <code>quads</code> in.jelly out_000.nq"},{"location":"conformance/tests/#negative_1","title":"Negative","text":"Name Description Data Input(s) Expected output quads_rdf_1_1 Single frame, a 'graph_end' row is in the stream. PHYSICAL_STREAM_TYPE_QUADS stream MUST NOT contain rows with the graph_end field set. <code>quads</code> in.jelly \u2014 quads_rdf_1_1 Single frame, a 'graph_start' row is in the stream. PHYSICAL_STREAM_TYPE_QUADS stream MUST NOT contain rows with the graph_start field set. <code>quads</code> in.jelly \u2014 quads_rdf_1_1 Single frame, a 'quad' row is in the stream. PHYSICAL_STREAM_TYPE_GRAPHS stream MUST NOT contain rows with the quad fields set. <code>quads</code> in.jelly \u2014 quads_rdf_1_1 Single frame, a 'triple' row is in the stream. PHYSICAL_STREAM_TYPE_QUADS stream MUST NOT contain rows with the triple field set. <code>quads</code> in.jelly \u2014 quads_rdf_1_1 Single frame, no field in the graph oneof is set. Repeated terms are not allowed in graph_start message. <code>quads</code> in.jelly \u2014"},{"location":"conformance/tests/#quads_rdf_1_1_generalized","title":"quads_rdf_1_1_generalized","text":"<p>5 positive, 0 negative</p>"},{"location":"conformance/tests/#positive_3","title":"Positive","text":"Name Description Data Input(s) Expected output quads_rdf_1_1_generalized Single frame, a set of generalized RDF quads that features all possible terms in any position and repeated across one (1) frame. Prefix table disabled. <code>quads</code> in.jelly out_000.nq quads_rdf_1_1_generalized Single frame, a set of generalized RDF quads that features all possible terms in any position. Prefix table disabled. <code>quads</code> in.jelly out_000.nq quads_rdf_1_1_generalized Three (3) frames. A set of generalized RDF quads that features all possible terms in any position and repeated across three (3) frames, focusing on reusing all lookup tables. Prefix table enabled. <code>quads</code> in.jelly out_000.nq quads_rdf_1_1_generalized Three (3) frames. A set of generalized RDF quads that features all possible terms in any position and repeated across three (3) frames. Prefix table disabled. <code>quads</code> in.jelly out_000.nq quads_rdf_1_1_generalized Three (3) frames. A set of generalized RDF quads that features all possible terms in any position and repeated across three (3) frames. Prefix table enabled. <code>quads</code> in.jelly out_000.nq"},{"location":"conformance/tests/#quads_rdf_star","title":"quads_rdf_star","text":"<p>7 positive, 3 negative</p>"},{"location":"conformance/tests/#positive_4","title":"Positive","text":"Name Description Data Input(s) Expected output quads_rdf_star Single frame with one simple quoted triple. Prefix table disabled. <code>quads</code> in.jelly out_000.nq quads_rdf_star Single frame with quoted triples as s/o or both. Prefix table disabled. <code>quads</code> in.jelly out_000.nq quads_rdf_star Single frame with quoted triples nested to level 10 in s and o. Diverse graph labels. Prefix table disabled. <code>quads</code> in.jelly out_000.nq quads_rdf_star Single frame with quoted triples of different formats and placements. Diverse graph labels. Prefix table disabled. <code>quads</code> in.jelly out_000.nq quads_rdf_star Single frame with quoted/asserted triples mix. Diverse graph labels. Prefix table disabled. <code>quads</code> in.jelly out_000.nq quads_rdf_star Single frame with quoted/asserted triples mix. Repeated statements inside/outside of quoted triples. Diverse graph labels. Prefix table disabled. <code>quads</code> in.jelly out_000.nq quads_rdf_star Three (3) frames with quoted/asserted triples mix across frames. Diverse graph labels. Prefix table enabled. <code>quads</code> in.jelly out_000.nq"},{"location":"conformance/tests/#negative_2","title":"Negative","text":"Name Description Data Input(s) Expected output quads_rdf_star Single frame, o_triple_term is fully empty {}. Repeated terms are prohibited in quoted triples. <code>quads</code> in.jelly \u2014 quads_rdf_star Single frame, o_triple_term is missing a s_bnode on the third nesting level, same s_bnode is repeated on the top nested levels. Repeated terms are prohibited in quoted triples. <code>quads</code> in.jelly \u2014 quads_rdf_star Single frame, s_triple_term is missing a p_iri. Repeated terms are prohibited in quoted triples. <code>quads</code> in.jelly \u2014"},{"location":"conformance/tests/#quads_rdf_star_generalized","title":"quads_rdf_star_generalized","text":"<p>6 positive, 3 negative</p>"},{"location":"conformance/tests/#positive_5","title":"Positive","text":"Name Description Data Input(s) Expected output quads_rdf_star_generalized Single frame. A set of generalized RDF-star quads with graph labels being one of BN/IRI/Literal/Default graph. Assertions of similar statements appear along quoted triples, utilizing the same s/p/o/g\u2026 <code>quads</code> in.jelly out_000.nq quads_rdf_star_generalized Single frame. A set of generalized RDF-star quads with graph labels being one of BN/IRI/Literal/Default graph. Quoted triples appear in different places inside one quad, with nesting up to three (3)\u2026 <code>quads</code> in.jelly out_000.nq quads_rdf_star_generalized Single frame. A set of generalized RDF-star quads with nesting up to six (6) levels. Prefix table disabled. <code>quads</code> in.jelly out_000.nq quads_rdf_star_generalized Single frame. A variety of generalized RDF-star quads with graph labels being BN/IRI/Literal/Default graph. Prefix table disabled. <code>quads</code> in.jelly out_000.nq quads_rdf_star_generalized Single frame. A variety of generalized RDF-star quads with graph labels being one of BN/IRI/Literal/Default graph mixed with quads assertions repeating statements from quoted triples. Assertions\u2026 <code>quads</code> in.jelly out_000.nq quads_rdf_star_generalized Three (3) frames. A variety of generalized RDF-star quads with graph labels being one of BN/IRI/Literal/Default graph. Assertions of similar statements appear along quoted triples, utilizing the same\u2026 <code>quads</code> in.jelly out_000.nq"},{"location":"conformance/tests/#negative_3","title":"Negative","text":"Name Description Data Input(s) Expected output quads_rdf_star_generalized Single frame, a quad row only has an empty s_triple_term, quad before has three (3) proper s_triple_terms. Repeated terms are prohibited in quoted triples. <code>quads</code> in.jelly out_000.nq quads_rdf_star_generalized Single frame, o_triple_term is missing p_literal on the second nesting level, the same p_literal is used before and after in nested triples and in the quad row before. Repeated terms are prohibited\u2026 <code>quads</code> in.jelly out_000.nq quads_rdf_star_generalized Single frame, s_triple_term is missing a p_literal on the first nesting level, p_literal on the deeper levels repeats. Repeated terms are prohibited in quoted triples. <code>quads</code> in.jelly out_000.nq"},{"location":"conformance/tests/#triples_rdf_1_1","title":"triples_rdf_1_1","text":"<p>17 positive, 10 negative</p>"},{"location":"conformance/tests/#positive_6","title":"Positive","text":"Name Description Data Input(s) Expected output triples_rdf_1_1 Four (4) frames, the first frame is empty. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_1_1 Four (4) frames, the last frame is empty. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_1_1 Four (4) frames, the second frame is empty. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_1_1 Single frame (non-delimited), a few basic triples. Prefix table enabled. <code>triples</code> in.jelly out_000.nt triples_rdf_1_1 Single frame, a few basic triples with repeated terms, including multiple subsequent usages of the same term. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_1_1 Single frame, a few basic triples. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_1_1 Single frame, a few basic triples. Prefix table disabled. Name table is updated to re-use name ids. <code>triples</code> in.jelly out_000.nt triples_rdf_1_1 Single frame, a few basic triples. Prefix table enabled and updated to re-use prefix ids. <code>triples</code> in.jelly out_000.nt triples_rdf_1_1 Single frame, a few basic triples. Prefix table enabled. <code>triples</code> in.jelly out_000.nt triples_rdf_1_1 Single frame, a few basic triples. Same stream options rows occur three (3) times in the frame. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_1_1 Single frame, a triple with unusual but valid IRIs. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_1_1 Six (6) frames, the first three (3) frames are empty. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_1_1 Ten (10) frames, the first two (2) frames are empty, frames number 4, 5, and 6 are empty. Frames number 9 and 10 are empty. Repeated triple is at the start of the seventh (7) frame. Prefix table\u2026 <code>triples</code> in.jelly out_000.nt triples_rdf_1_1 Three (3) frames. Datatypes and names defined in one frame and referenced in the subsequent frames, also requiring name table updates across frames. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_1_1 Two (2) frames, a few basic triples with repeated terms. Repeated terms (whole triple) occur as the first row in the second frame. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_1_1 Two (2) frames, logical type = LOGICAL_STREAM_TYPE_GRAPHS. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_1_1 Two (2) frames, logical type = LOGICAL_STREAM_TYPE_SUBJECT_GRAPHS. Prefix table disabled. <code>triples</code> in.jelly out_000.nt"},{"location":"conformance/tests/#negative_4","title":"Negative","text":"Name Description Data Input(s) Expected output triples_rdf_1_1 Single frame, Literal has datatype index set to 0. In contrast to prefix and name tables the value of 0 is invalid in datatype table. <code>triples</code> in.jelly \u2014 triples_rdf_1_1 Single frame, a quad row present in the PHYSICAL_STREAM_TYPE_TRIPLES stream. PHYSICAL_STREAM_TYPE_TRIPLES MUST NOT contain rows with the quad field set. <code>triples</code> in.jelly \u2014 triples_rdf_1_1 Single frame, invalid name table reference (0). Invalid name ID outside of bounds of the lookup table due to misused 0. The producer of the stream MUST NOT exceed the maximum size of the lookup. <code>triples</code> in.jelly \u2014 triples_rdf_1_1 Single frame, invalid prefix table reference. Invalid prefix ID outside of bounds of the lookup table. The producer of the stream MUST NOT exceed the maximum size of the lookup. <code>triples</code> in.jelly \u2014 triples_rdf_1_1 Single frame, max_datatype_table_size set to 10000000. For security reasons, consumers must always validate that the requested size of a prefix, name, or datatype lookup table is not overly large.\u2026 <code>triples</code> in.jelly \u2014 triples_rdf_1_1 Single frame, max_name_table_size set to 10000000. For security reasons, consumers must always validate that the requested size of a prefix, name, or datatype lookup table is not overly large. The\u2026 <code>triples</code> in.jelly \u2014 triples_rdf_1_1 Single frame, max_prefix_table_size set to 10000000. For security reasons, consumers must always validate that the requested size of a prefix, name, or datatype lookup table is not overly large. The\u2026 <code>triples</code> in.jelly \u2014 triples_rdf_1_1 Single frame, prefix row is in the stream, when prefix lookup table is disabled. Prefix table usage is prohibited if max_prefix_table_size is set to 0 (lookup disabled). <code>triples</code> in.jelly \u2014 triples_rdf_1_1 Single frame, prefix table entry with ID outside of max_prefix_table_size is in the stream. The producer of the stream MUST NOT exceed the maximum size of the lookup. <code>triples</code> in.jelly \u2014 triples_rdf_1_1 Single frame, repeated term (s_iri and o_iri) appears in the first statement row. Repeated terms MUST NOT occur in the first statement row of the stream. <code>triples</code> in.jelly \u2014"},{"location":"conformance/tests/#triples_rdf_1_1_generalized","title":"triples_rdf_1_1_generalized","text":"<p>5 positive, 0 negative</p>"},{"location":"conformance/tests/#positive_7","title":"Positive","text":"Name Description Data Input(s) Expected output triples_rdf_1_1_generalized Four (4) frames, a set of generalized RDF triples that features all possible terms in any position and repeated across four (4) frames, reusing all lookup tables. Prefix table enabled. <code>triples</code> in.jelly out_000.nt triples_rdf_1_1_generalized Single frame, a set of generalized RDF triples that features all possible terms in any position and repeated across one (1) frame. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_1_1_generalized Single frame, a set of generalized RDF triples that features all possible terms in any position. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_1_1_generalized Three (3) frames, a set of generalized RDF triples that features all possible terms in any position and repeated across three (3) frames. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_1_1_generalized Three (3) frames, a set of generalized RDF triples that features all possible terms in any position and repeated across three (3) frames. Prefix table enabled. <code>triples</code> in.jelly out_000.nt"},{"location":"conformance/tests/#triples_rdf_star","title":"triples_rdf_star","text":"<p>8 positive, 3 negative</p>"},{"location":"conformance/tests/#positive_8","title":"Positive","text":"Name Description Data Input(s) Expected output triples_rdf_star Single frame utilizing BNs/IRIs for subject and BNs/IRI/Literals for objects in quoted triples. Prefix table enabled. <code>triples</code> in.jelly out_000.nt triples_rdf_star Single frame, a triple with nesting level 3, subject is repeated in quoted triples. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_star Single frame, one triple with a quoted triple as a subject. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_star Single frame, three triples showcasing a quoted triple as a subject/object/both. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_star Single frame, three triples showing a quoted triple as a subject/object/both. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_star Single frame, triples with nesting level 10 as subject/object. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_star Single frame, triples with nesting level 3 as subject/object. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_star Two (2) frames, triples have quoted triples in s and/or o. Prefix table enabled. <code>triples</code> in.jelly out_000.nt"},{"location":"conformance/tests/#negative_5","title":"Negative","text":"Name Description Data Input(s) Expected output triples_rdf_star Single frame, missing a p_iri on the 7th (out of 10) nesting level of a s_triple_term. Repeated terms are prohibited in quoted triples. <code>triples</code> in.jelly \u2014 triples_rdf_star Single frame, o_triple_term is empty in a triple with repeated s/p. Repeated terms are prohibited in quoted triples. <code>triples</code> in.jelly \u2014 triples_rdf_star Single frame, o_triple_term is missing an o_literal. Repeated terms are prohibited in quoted triples. <code>triples</code> in.jelly \u2014"},{"location":"conformance/tests/#triples_rdf_star_generalized","title":"triples_rdf_star_generalized","text":"<p>6 positive, 3 negative</p>"},{"location":"conformance/tests/#positive_9","title":"Positive","text":"Name Description Data Input(s) Expected output triples_rdf_star_generalized Single frame. A set of generalized RDF-star triples with nesting up to six (6) levels, with quoted triples repeatedly appearing in s/p/o. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_star_generalized Single frame. A set of generalized RDF-star triples with quoted triples appearing in different places inside one RDF-star statement. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_star_generalized Single frame. A set of generalized RDF-star triples with repeating terms inside/outside of quoted triples. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_star_generalized Single frame. A variety of generalized RDF-star statements along with triples assertions. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_star_generalized Single frame. A variety of generalized RDF-star statements. Prefix table disabled. <code>triples</code> in.jelly out_000.nt triples_rdf_star_generalized Three (3) frames. A set of generalized RDF-star triples with repeating terms inside/outside of quoted triples, re-using all lookup tables. Prefix table enabled. <code>triples</code> in.jelly out_000.nt"},{"location":"conformance/tests/#negative_6","title":"Negative","text":"Name Description Data Input(s) Expected output triples_rdf_star_generalized Single frame, o_triple_term is missing an o_literal on the third nesting level. Repeated terms are prohibited in quoted triples. <code>triples</code> in.jelly \u2014 triples_rdf_star_generalized Single frame, p_triple_term is missing a s_literal used in quoted triples befoere and after and in the basic triple before quoted. Repeated terms are prohibited in quoted triples. <code>triples</code> in.jelly \u2014 triples_rdf_star_generalized Single frame, s_triple_term is empty {}. Repeated terms are prohibited in quoted triples. <code>triples</code> in.jelly \u2014"},{"location":"conformance/tests/#to-jelly-serialize","title":"To Jelly (serialize)","text":""},{"location":"conformance/tests/#jump-to-category_1","title":"Jump to category","text":"<ul> <li>graphs_rdf_1_1</li> <li>graphs_rdf_star</li> <li>quads_rdf_1_1</li> <li>quads_rdf_1_1_generalized</li> <li>quads_rdf_star</li> <li>quads_rdf_star_generalized</li> <li>triples_rdf_1_1</li> <li>triples_rdf_1_1_generalized</li> <li>triples_rdf_star</li> <li>triples_rdf_star_generalized</li> </ul>"},{"location":"conformance/tests/#graphs_rdf_1_2","title":"graphs_rdf_1_1","text":"<p>9 positive, 0 negative</p>"},{"location":"conformance/tests/#positive_10","title":"Positive","text":"Name Description Data Input(s) Expected output graphs_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>graphs</code> stream_options.jelly out.jelly graphs_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>graphs</code> stream_options.jelly out.jelly graphs_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=4, max-datatype-table-size=2. <code>graphs</code> stream_options.jelly out.jelly graphs_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>graphs</code> stream_options.jelly out.jelly graphs_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=4, max-datatype-table-size=4. <code>graphs</code> stream_options.jelly out.jelly graphs_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>graphs</code> stream_options.jelly out.jelly graphs_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>graphs</code> stream_options.jelly out.jelly graphs_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>graphs</code> stream_options.jelly out.jelly graphs_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>graphs</code> stream_options.jelly out.jelly"},{"location":"conformance/tests/#graphs_rdf_star_1","title":"graphs_rdf_star","text":"<p>7 positive, 0 negative</p>"},{"location":"conformance/tests/#positive_11","title":"Positive","text":"Name Description Data Input(s) Expected output graphs_rdf_star Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=32, max-prefix-table-size=0, max-datatype-table-size=4. <code>graphs</code> stream_options.jelly out.jelly graphs_rdf_star Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=24, max-prefix-table-size=8, max-datatype-table-size=2. <code>graphs</code> stream_options.jelly out.jelly graphs_rdf_star Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=16, max-prefix-table-size=0, max-datatype-table-size=4. <code>graphs</code> stream_options.jelly out.jelly graphs_rdf_star Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=16, max-prefix-table-size=0, max-datatype-table-size=4. <code>graphs</code> stream_options.jelly out.jelly graphs_rdf_star Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=16, max-prefix-table-size=0, max-datatype-table-size=4. <code>graphs</code> stream_options.jelly out.jelly graphs_rdf_star Only IRIs as terms. Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=0. <code>graphs</code> stream_options.jelly out.jelly graphs_rdf_star Only IRIs as terms. Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=0. <code>graphs</code> stream_options.jelly out.jelly"},{"location":"conformance/tests/#quads_rdf_1_2","title":"quads_rdf_1_1","text":"<p>6 positive, 0 negative</p>"},{"location":"conformance/tests/#positive_12","title":"Positive","text":"Name Description Data Input(s) Expected output quads_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>quads</code> stream_options.jelly out.jelly quads_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=4, max-datatype-table-size=4. <code>quads</code> stream_options.jelly out.jelly quads_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>quads</code> stream_options.jelly out.jelly quads_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>quads</code> stream_options.jelly out.jelly quads_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>quads</code> stream_options.jelly out.jelly quads_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>quads</code> stream_options.jelly out.jelly"},{"location":"conformance/tests/#quads_rdf_1_1_generalized_1","title":"quads_rdf_1_1_generalized","text":"<p>5 positive, 0 negative</p>"},{"location":"conformance/tests/#positive_13","title":"Positive","text":"Name Description Data Input(s) Expected output quads_rdf_1_1_generalized Stream options are: generalized-statements=true, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>quads</code> stream_options.jelly out.jelly quads_rdf_1_1_generalized Stream options are: generalized-statements=true, rdf-star=false, max-name-table-size=8, max-prefix-table-size=4, max-datatype-table-size=2. <code>quads</code> stream_options.jelly out.jelly quads_rdf_1_1_generalized Stream options are: generalized-statements=true, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>quads</code> stream_options.jelly out.jelly quads_rdf_1_1_generalized Stream options are: generalized-statements=true, rdf-star=false, max-name-table-size=8, max-prefix-table-size=4, max-datatype-table-size=4. <code>quads</code> stream_options.jelly out.jelly quads_rdf_1_1_generalized Stream options are: generalized-statements=true, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>quads</code> stream_options.jelly out.jelly"},{"location":"conformance/tests/#quads_rdf_star_1","title":"quads_rdf_star","text":"<p>7 positive, 0 negative</p>"},{"location":"conformance/tests/#positive_14","title":"Positive","text":"Name Description Data Input(s) Expected output quads_rdf_star Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=32, max-prefix-table-size=0, max-datatype-table-size=0. <code>quads</code> stream_options.jelly out.jelly quads_rdf_star Altered input from pos_004. Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=24, max-prefix-table-size=8, max-datatype-table-size=2. 25 rows per frame. <code>quads</code> stream_options.jelly out.jelly quads_rdf_star Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=16, max-prefix-table-size=0, max-datatype-table-size=4. <code>quads</code> stream_options.jelly out.jelly quads_rdf_star Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=16, max-prefix-table-size=0, max-datatype-table-size=4. <code>quads</code> stream_options.jelly out.jelly quads_rdf_star Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=16, max-prefix-table-size=0, max-datatype-table-size=4. <code>quads</code> stream_options.jelly out.jelly quads_rdf_star Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=0. <code>quads</code> stream_options.jelly out.jelly quads_rdf_star Only IRIs as terms. Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=0. <code>quads</code> stream_options.jelly out.jelly"},{"location":"conformance/tests/#quads_rdf_star_generalized_1","title":"quads_rdf_star_generalized","text":"<p>6 positive, 0 negative</p>"},{"location":"conformance/tests/#positive_15","title":"Positive","text":"Name Description Data Input(s) Expected output quads_rdf_star_generalized Stream options are: generalized-statements=true, rdf-star=true, max-name-table-size=16, max-prefix-table-size=0, max-datatype-table-size=4. <code>quads</code> stream_options.jelly out.jelly quads_rdf_star_generalized Stream options are: generalized-statements=true, rdf-star=true, max-name-table-size=16, max-prefix-table-size=0, max-datatype-table-size=4. <code>quads</code> stream_options.jelly out.jelly quads_rdf_star_generalized Stream options are: generalized-statements=true, rdf-star=true, max-name-table-size=16, max-prefix-table-size=0, max-datatype-table-size=4. <code>quads</code> stream_options.jelly out.jelly quads_rdf_star_generalized Stream options are: generalized-statements=true, rdf-star=true, max-name-table-size=16, max-prefix-table-size=0, max-datatype-table-size=4. <code>quads</code> stream_options.jelly out.jelly quads_rdf_star_generalized Stream options are: generalized-statements=true, rdf-star=true, max-name-table-size=16, max-prefix-table-size=0, max-datatype-table-size=4. <code>quads</code> stream_options.jelly out.jelly quads_rdf_star_generalized Stream options are: generalized-statements=true, rdf-star=true, max-name-table-size=20, max-prefix-table-size=6, max-datatype-table-size=4, rows-per-frame=50. <code>quads</code> stream_options.jelly out.jelly"},{"location":"conformance/tests/#triples_rdf_1_2","title":"triples_rdf_1_1","text":"<p>16 positive, 2 negative</p>"},{"location":"conformance/tests/#positive_16","title":"Positive","text":"Name Description Data Input(s) Expected output triples_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>triples</code> stream_options.jelly out.jelly triples_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=0. <code>triples</code> stream_options.jelly out.jelly triples_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>triples</code> stream_options.jelly out.jelly triples_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=0. <code>triples</code> stream_options.jelly out.jelly triples_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>triples</code> stream_options.jelly out.jelly triples_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=0. <code>triples</code> stream_options.jelly out.jelly triples_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>triples</code> stream_options.jelly out.jelly triples_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=0. <code>triples</code> stream_options.jelly out.jelly triples_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=0. <code>triples</code> stream_options.jelly out.jelly triples_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=0. <code>triples</code> stream_options.jelly out.jelly triples_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=0. <code>triples</code> stream_options.jelly out.jelly triples_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=0. <code>triples</code> stream_options.jelly out.jelly triples_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=0. <code>triples</code> stream_options.jelly out.jelly triples_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>triples</code> stream_options.jelly out.jelly triples_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=0. <code>triples</code> stream_options.jelly out.jelly triples_rdf_1_1 Stream options are: opt.physical-type=TRIPLES, opt.logical-type=FLAT_TRIPLES, generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=0. <code>triples</code> stream_options.jelly out.jelly"},{"location":"conformance/tests/#negative_7","title":"Negative","text":"Name Description Data Input(s) Expected output triples_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=0. <code>triples</code> stream_options.jelly \u2014 triples_rdf_1_1 Stream options are: generalized-statements=false, rdf-star=false, max-name-table-size=7, max-prefix-table-size=0, max-datatype-table-size=0. <code>triples</code> stream_options.jelly \u2014"},{"location":"conformance/tests/#triples_rdf_1_1_generalized_1","title":"triples_rdf_1_1_generalized","text":"<p>5 positive, 0 negative</p>"},{"location":"conformance/tests/#positive_17","title":"Positive","text":"Name Description Data Input(s) Expected output triples_rdf_1_1_generalized Stream options are: generalized-statements=true, rdf-star=false, max-name-table-size=8, max-prefix-table-size=4, max-datatype-table-size=2. <code>triples</code> stream_options.jelly out.jelly triples_rdf_1_1_generalized Stream options are: generalized-statements=true, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>triples</code> stream_options.jelly out.jelly triples_rdf_1_1_generalized Stream options are: generalized-statements=true, rdf-star=false, max-name-table-size=8, max-prefix-table-size=4, max-datatype-table-size=4. <code>triples</code> stream_options.jelly out.jelly triples_rdf_1_1_generalized Stream options are: generalized-statements=true, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>triples</code> stream_options.jelly out.jelly triples_rdf_1_1_generalized Stream options are: generalized-statements=true, rdf-star=false, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=4. <code>triples</code> stream_options.jelly out.jelly"},{"location":"conformance/tests/#triples_rdf_star_1","title":"triples_rdf_star","text":"<p>8 positive, 0 negative</p>"},{"location":"conformance/tests/#positive_18","title":"Positive","text":"Name Description Data Input(s) Expected output triples_rdf_star BNs, IRIs, and Literals used. Quoted triples appear in subject/objects. Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=10, max-prefix-table-size=8,\u2026 <code>triples</code> stream_options.jelly out.jelly triples_rdf_star Only IRIs as terms. Quoted triples have the same predicate. Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=16, max-prefix-table-size=0, max-datatype-table-size=0. <code>triples</code> stream_options.jelly out.jelly triples_rdf_star Only IRIs as terms. Quoted triples have the same subject. Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=16, max-prefix-table-size=0, max-datatype-table-size=0. <code>triples</code> stream_options.jelly out.jelly triples_rdf_star Only IRIs as terms. Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=0. <code>triples</code> stream_options.jelly out.jelly triples_rdf_star Only IRIs as terms. Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=0. <code>triples</code> stream_options.jelly out.jelly triples_rdf_star Only IRIs as terms. Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=0. <code>triples</code> stream_options.jelly out.jelly triples_rdf_star Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=10, max-prefix-table-size=8, max-datatype-table-size=2. 30 rows per frame. <code>triples</code> stream_options.jelly out.jelly triples_rdf_star Only IRIs as terms. Stream options are: generalized-statements=false, rdf-star=true, max-name-table-size=8, max-prefix-table-size=0, max-datatype-table-size=0. <code>triples</code> stream_options.jelly out.jelly"},{"location":"conformance/tests/#triples_rdf_star_generalized_1","title":"triples_rdf_star_generalized","text":"<p>6 positive, 0 negative</p>"},{"location":"conformance/tests/#positive_19","title":"Positive","text":"Name Description Data Input(s) Expected output triples_rdf_star_generalized Stream options are: generalized-statements=true, rdf-star=true, max-name-table-size=16, max-prefix-table-size=6, max-datatype-table-size=3. 25 rows per frame. <code>triples</code> stream_options.jelly out.jelly triples_rdf_star_generalized Stream options are: generalized-statements=true, rdf-star=true, max-name-table-size=16, max-prefix-table-size=0, max-datatype-table-size=4. <code>triples</code> stream_options.jelly out.jelly triples_rdf_star_generalized Stream options are: generalized-statements=true, rdf-star=true, max-name-table-size=16, max-prefix-table-size=0, max-datatype-table-size=4. <code>triples</code> stream_options.jelly out.jelly triples_rdf_star_generalized Stream options are: generalized-statements=true, rdf-star=true, max-name-table-size=16, max-prefix-table-size=0, max-datatype-table-size=4. <code>triples</code> stream_options.jelly out.jelly triples_rdf_star_generalized Stream options are: generalized-statements=true, rdf-star=true, max-name-table-size=16, max-prefix-table-size=0, max-datatype-table-size=4. <code>triples</code> stream_options.jelly out.jelly triples_rdf_star_generalized Stream options are: generalized-statements=true, rdf-star=true, max-name-table-size=16, max-prefix-table-size=0, max-datatype-table-size=4. <code>triples</code> stream_options.jelly out.jelly"},{"location":"contributing/","title":"Contributing","text":"<p>Jelly is an open project \u2013 you are welcome to submit issues, pull requests, or just ask questions. By participating in this project, you are expected to follow our Code of conduct. Be kind, inclusive, and constructive.</p> <p> Chat with us on Discord</p>"},{"location":"contributing/#contributing-to-the-jelly-specification","title":"Contributing to the Jelly specification","text":"<p>The Jelly Protocol Buffers and gRPC definitions are in the jelly-protobuf repository. If you want to contribute to the specification, it is strongly recommended that you first open an issue there to discuss your idea.</p> <p>The specification documents are edited in the same way as other documentation pages. See the next section for details.</p>"},{"location":"contributing/#contributing-to-implementations","title":"Contributing to implementations","text":"<p>Best way to start is to hop on the Jelly Discord chat and ask questions \u2013 the developers and community members will be happy to help you get started. You can also jump straight into the implementations:</p>"},{"location":"contributing/#jelly-jvm-java","title":"Jelly-JVM (Java)","text":"<ul> <li>Jelly-JVM contributing page</li> <li>Jelly-JVM documentation includes the developer guide, explaining the technical aspects of contributing to it.</li> <li>GitHub repository</li> <li>Issue tracker</li> </ul>"},{"location":"contributing/#pyjelly-python","title":"pyjelly (Python)","text":"<ul> <li>pyjelly contributing page</li> <li>pyjelly documentation </li> <li>GitHub repository</li> <li>Issue tracker</li> </ul>"},{"location":"contributing/#jelly_rs-rust-experimental","title":"jelly_rs (Rust, experimental)","text":"<ul> <li>GitHub repository</li> <li>Issue tracker</li> </ul>"},{"location":"contributing/#new-implementations-and-integrations","title":"New implementations and integrations","text":"<p>Would you like to integrate Jelly into your project or implement it in a new language? You are welcome to do so! Check out our tips for implementing Jelly in a new language. You can also join the Jelly Discord chat to discuss your plans and get help. Or, if you have a commercial project in mind, you can contact NeverBlink for professional support.</p>"},{"location":"contributing/#editing-documentation","title":"Editing documentation","text":"<p>The documentation is written in Markdown and built using MkDocs, using Material for MkDocs.</p> <p>To edit a documentation page, simply click the  button in the top-right of the page:</p> <p></p> <p>It will take you to GitHub, where you can edit the Markdown file and submit a pull request. You can also clone the repository and edit the files locally. The source files are in the <code>docs</code> directory.</p> <p>Note: the <code>reference.md</code> file is automatically generated from the Jelly Protocol Buffers definitions. Do not edit it directly.</p>"},{"location":"contributing/#macros","title":"Macros","text":"<p>The documentation makes use of several macros for generating links, displaying the software version, etc. The macros are used in the Markdown files like this:</p> <pre><code>**Version**: {{ proto_version() }}\n</code></pre> <p>Which yields: </p> <p>Version: dev</p> <p>The list of available macros can be found in the <code>main.py</code> file in the root of the repository.</p>"},{"location":"contributing/#local-testing-of-the-website","title":"Local testing of the website","text":"<p>Install the project's dependencies from <code>requirements.txt</code> (preferably in a virtual environment). Then, run <code>mkdocs serve</code> to compile the docs and serve them locally for testing.</p> <pre><code># Create a virtual environment \u2013 use your preferred tool here\npython3 -m venv venv\nsource venv/bin/activate\n\n# Install dependencies\npip install -r requirements.txt\n\n# Run the local server\nmkdocs serve\n</code></pre>"},{"location":"contributing/#making-a-jelly-protocol-release","title":"Making a Jelly protocol release","text":"<p>Jelly protocol releases are handled from the <code>jelly-protobuf</code> repository. To make a new tagged release, follow these steps:</p> <ol> <li>Clone the <code>jelly-protobuf</code> repository.</li> <li>Make sure you are on the <code>main</code> branch and that it is up-to-date: <code>git checkout main &amp;&amp; git pull</code></li> <li>Create a new tag for the release. For example, for version 1.2.3: <code>git tag v1.2.3</code></li> <li>Push the tag to GitHub: <code>git push origin v1.2.3</code></li> </ol> <p>The CI/CD pipeline will automatically pick up the new tag and make a tagged release of the documentation, including the protocol specification. The spec pages use macros to display the current version, so they will be updated automatically.</p> <p>After a new protocol release, you should also update the implementations to use it.</p>"},{"location":"contributing/#further-reading","title":"Further reading","text":"<ul> <li>Material for MkDocs reference</li> <li>MkDocs documentation</li> <li>Macro plugin documentation</li> </ul>"},{"location":"contributing/#editing-jelly-jvm-documentation","title":"Editing Jelly-JVM documentation","text":"<p>Use the exact same process as for the website documentation. The Jelly-JVM documentation sources are in the <code>jelly-jvm</code> repository, <code>docs/docs</code> directory.</p>"},{"location":"contributing/#see-also","title":"See also","text":"<ul> <li>License and citation</li> <li>User guide</li> <li>Applications using Jelly</li> </ul>"},{"location":"contributing/code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p>"},{"location":"contributing/code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"contributing/code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"contributing/code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"contributing/code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"contributing/code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at community@neverblink.eu. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"contributing/code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"contributing/code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"contributing/code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"contributing/code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"contributing/code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"contributing/code_of_conduct/#attribution","title":"Attribution","text":"<p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"licensing/","title":"Licensing and citation","text":"<ul> <li>The Jelly Protocol Buffers and gRPC definitions are licensed under the Apache License 2.0.</li> <li>The documentation of Jelly (this website) is licensed under the Creative Commons Attribution 4.0 license.</li> <li>The Jelly-JVM implementation is licensed under the Apache License 2.0.</li> <li>The pyjelly implementation is licensed under the Apache License 2.0.</li> <li>The <code>jelly-cli</code> command-line tool is licensed under the Apache License 2.0.</li> </ul>"},{"location":"licensing/#jelly-maintainer","title":"Jelly maintainer","text":"<p>The entire Jelly tool stack is currently maintained by NeverBlink.</p> <p>The Jelly protocol and Jelly-JVM were originally created by Piotr Sowi\u0144ski (GitHub).</p>"},{"location":"licensing/#attribution-citation","title":"Attribution / citation","text":"<p>If you use Jelly in your research, please cite the paper about it:</p> <p>Sowi\u0144ski, P., Bogacka, K., Danilenka, A., Kozlov, N. (2025). Jelly: a Fast and Convenient RDF Serialization Format. In arXiv preprint arXiv:2506.11298. Developers Workshop, co-located with SEMANTiCS'25: International Conference on Semantic Systems, September 3-5, 2025, Vienna, Austria. DOI: 10.48550/arXiv.2506.11298</p> <p>Or use this BibTeX entry:</p> <pre><code>@article{sowinski2025jelly,\n  title = {Jelly: a Fast and Convenient RDF Serialization Format},\n  author = {Sowi{\\'n}ski, Piotr and Bogacka, Karolina and Danilenka, Anastasiya and Kozlov, Nikita},\n  journal = {arXiv preprint arXiv:2506.11298},\n  note = {Developers Workshop, co-located with SEMANTiCS'25: International Conference on Semantic Systems, September 3-5, 2025, Vienna, Austria},\n  year = {2025},\n  doi = {10.48550/arXiv.2506.11298},\n}\n</code></pre> <p>If you use Jelly-Patch, please cite this paper:</p> <p>Sowi\u0144ski, P., Grzymkowski, K., Danilenka, A. (2025). Jelly-Patch: a Fast Format for Recording Changes in RDF Datasets. In arXiv preprint arXiv:2507.23499. DOI: 10.48550/arXiv.2507.23499</p> <pre><code>@article{sowinski2025jellypatch,\n  title = {Jelly-Patch: a Fast Format for Recording Changes in RDF Datasets},\n  author = {Sowi{\\'n}ski, Piotr and Grzymkowski, Kacper and Danilenka, Anastasiya},\n  journal = {arXiv preprint arXiv:2507.23499},\n  year = {2025},\n  doi = {10.48550/arXiv.2507.23499},\n}\n</code></pre>"},{"location":"licensing/#all-papers-and-presentations-about-jelly","title":"All papers and presentations about Jelly","text":"<ul> <li>Sowi\u0144ski, P., Grzymkowski, K., &amp; Danilenka, A. (2025). Jelly-Patch: a Fast Format for Recording Changes in RDF Datasets. arXiv preprint arXiv:2507.23499, accepted at the 24th International Semantic Web Conference (ISWC) 2025 Posters and Demos, 2\u20136 November, 2025, Nara, Japan, 2025. DOI: 10.48550/arXiv.2507.23499</li> <li>Sowi\u0144ski, P., Kuhn, T., &amp; Bogacka, K. (2025). Tackling inter-service RDF communication bottlenecks in the Nanopublication network with Jelly. Industry Track presentation at SEMANTiCS 2025, 2\u20135 September, 2025, Vienna, Austria, 2025.<ul> <li>Slides</li> <li>One-page abstract</li> </ul> </li> <li>Sowi\u0144ski, P., Bogacka, K., Danilenka, A., Kozlov, N. (2025). Jelly: a Fast and Convenient RDF Serialization Format. In arXiv preprint arXiv:2506.11298. Developers Workshop, co-located with SEMANTiCS'25: International Conference on Semantic Systems, September 3-5, 2025, Vienna, Austria. DOI: 10.48550/arXiv.2506.11298<ul> <li>Slides</li> </ul> </li> <li>Sowi\u0144ski, P., Wasielewska-Michniewska, K., Ganzha, M., &amp; Paprzycki, M. (2022, October). Efficient RDF streaming for the edge-cloud continuum. In 2022 IEEE 8th World Forum on Internet of Things (WF-IoT) (pp. 1-8). IEEE. DOI: 10.1109/WF-IoT54382.2022.10152225</li> </ul>"},{"location":"licensing/#see-also","title":"See also","text":"<ul> <li>Contributing to Jelly</li> <li>Applications using Jelly</li> <li>Projects and funding</li> </ul>"},{"location":"licensing/projects/","title":"Projects and funding","text":"<p>The development of the Jelly protocol, its implementations, and supporting tooling was funded from various sources, including the projects listed below.</p>"},{"location":"licensing/projects/#startup-booster-poland-hugething-sector-agnostic","title":"Startup Booster Poland \u2013 HugeThing Sector Agnostic","text":"<p>NeverBlink has received a grant from the European Funds for Smart Economy in Poland (FENG) for a project to (1) introduce a new feature for the Jelly protocol, (2) implement the Jelly protocol in Python, and (3) test the protocol's integration with existing systems on new test infrastructure, funded from the grant.</p> <p>Project no. 0021/2025, funding program FENG.02.28-IP.02-0006/23 (Startup Booster Poland \u2013 HugeThing Sector Agnostic).</p> <p>Total cost of project: 149 941,44 PLN  Contribution from European Funds: 149 941,44 PLN\u200b</p> <p></p>"},{"location":"licensing/projects/#see-also","title":"See also","text":"<ul> <li>Licensing and citation</li> <li>Contributing to Jelly</li> </ul>"},{"location":"performance/","title":"Performance benchmarks","text":"<p>The following results were obtained by benchmarking Jelly-JVM against serializations built into Apache Jena (including binary formats).</p> <p>The benchmarks were performed on two kinds of RDF streams (according to the RDF-STaX taxonomy):</p> <ul> <li>Flat RDF streams \u2013 streams of RDF triples or quads. This is the \"classic\" serialization \u2013 equivalent to, for example N-Triples or N-Quads.</li> <li>Grouped RDF streams \u2013 streams of RDF graphs or datasets.</li> </ul> <p>Jelly has a major performance advantage especially in grouped RDF streams. This is mostly due to Jelly being the only tested serialization that natively supports grouped RDF streams. Because of this, Jelly can exploit the repeating terms, prefixes, and structures in the stream to achieve much better compression and serialization speed.</p> <p>If you are only interested in parsing/writing a single graph or dataset, look at the flat streaming results.</p>"},{"location":"performance/#benchmark-setup","title":"Benchmark setup","text":"<p>All benchmarks presented here were performed using the RiverBench benchmark suite, version 2.1.0. Out of the 13 used datasets (all datasets available in RiverBench 2.1.0), 1 used RDF-star, and 3 included RDF quads/datasets. You can find the links to the specific used RiverBench profiles and tasks in the results below.</p> <p>The benchmarks were executed using this code (Apache 2.0 license) in a JVM with options: <code>-Xms1G -Xmx32G</code>. The large heap size was necessary to fit the benchmark data in memory, making the benchmark independent of disk I/O.</p> <p>Hardware: AMD Ryzen 9 7900 (12-core, 24-thread, 5.0 GHz); 64 GB RAM (DDR5 5600 MT/s). The disk was not used during the benchmarks (all data was in memory). The throughput benchmarks are single-threaded, but the JVM was allowed to use all available cores for garbage collection, JIT compilation, and other tasks.</p> <p>Software: Linux kernel 6.10.11, Oracle GraalVM 23.0.2+7.1, Apache Jena 5.3.0, Eclipse RDF4J 5.1.2, Jelly-JVM 2.7.0.</p>"},{"location":"performance/#tested-methods","title":"Tested methods","text":"<ul> <li>W3C RDF/XML (Apache Jena 5.3.0, <code>RDFXML_PLAIN</code>)</li> <li>W3C N-Triples / N-Quads (Apache Jena 5.3.0, <code>NTRIPLES</code> and <code>NQUADS</code>)</li> <li>W3C JSON-LD (Apache Jena 5.3.0, <code>JSONLD_PLAIN</code>)</li> <li>W3C Turtle / TriG (Apache Jena 5.3.0)<ul> <li>In grouped streaming, the default (<code>TURTLE_PRETTY</code> and <code>TRIG_PRETTY</code>) Turtle/TriG variant was used. </li> <li>In flat streaming, the <code>TURTLE_BLOCKS</code> and <code>TRIG_BLOCKS</code> variant was used. See Jena's documentation on streaming writers for more details.</li> </ul> </li> <li>Jena's RDF binary Protobuf format (Apache Jena 5.3.0, <code>RDF_PROTO</code>)</li> <li>Jena's RDF binary Thrift format (Apache Jena 5.3.0, <code>RDF_THRIFT</code>)</li> <li>RDF4J Binary RDF Format (Eclipse RDF4J 5.0.2, <code>BINARY</code>)<ul> <li>Note: to avoid confusion, on this page we only show the performance results for Apache Jena. The results for RDF4J can be found here: RDF4J performance.</li> </ul> </li> <li>Jelly (Jelly-JVM 2.7.0, \"big\" preset)     <pre><code>max_name_table_size = 4000;\nmax_prefix_table_size = 150;\nmax_datatype_table_size = 32;\n</code></pre></li> <li>Jelly without prefix compression (Jelly-JVM 2.7.0, \"big\" preset with prefix table disabled)     <pre><code>max_name_table_size = 4000;\nmax_prefix_table_size = 0;  // Prefix table disabled\nmax_datatype_table_size = 32;\n</code></pre></li> </ul>"},{"location":"performance/#results","title":"Results","text":"<p>RDF4J performance results</p> <p>This page only shows the performance results for Apache Jena. The results for RDF4J can be found here: RDF4J performance.</p> <p>Warning</p> <p>The results below were averaged over all datasets used in the benchmarks. For RDF/XML and JSON-LD the results are incomplete due to missing support for some datasets. For them, only the datasets that were successfully processed are included in the averages.</p> <p>RDF/XML failed on 5 out of 13 datasets due to lack of support for RDF datasets (<code>assist-iot-weather-graphs</code>, <code>citypulse-graphs</code>, <code>nanopubs</code>), RDF-star (<code>yago-annotated-facts</code>), and no support for encoding ASCII control characters (<code>politiquices</code> \u2013 see RiverBench documentation for more details).</p> <p>JSON-LD failed on 1 out of 13 datasets due to lack of support for RDF-star (<code>yago-annotated-facts</code>).</p>"},{"location":"performance/#grouped-streaming-serialized-size","title":"Grouped streaming serialized size","text":"<ul> <li>RiverBench task: <code>stream-compression</code> (2.1.0)</li> <li>RiverBench profile: <code>stream-mixed-rdfstar</code> (2.1.0)</li> <li>The entire (full-length) datasets were used for this benchmark.</li> <li>The data was serialized to a byte-counting output stream and then discarded.</li> </ul> Relative serialized representation size of a stream of RDF graphs or RDF datasets, geometric mean over all datasets. N-Triples/N-Quads was used as the baseline (100%).* Partial results for RDF/XML and JSON-LD (some datasets not supported). <p>Jelly has a major advantage here (~2x smaller than the next best format, RDF4J Binary), but that is because it is the only format that natively supports grouped RDF streams. The other formats cannot exploit the repeating patterns between elements in the stream, leading to much larger sizes.</p>"},{"location":"performance/#flat-streaming-serialized-size","title":"Flat streaming serialized size","text":"<ul> <li>RiverBench task: <code>flat-compression</code> (2.1.0)</li> <li>RiverBench profile: <code>flat-mixed-rdfstar</code> (2.1.0)</li> <li>The entire (full-length) datasets were used for this benchmark.</li> <li>The data was serialized to a byte-counting output stream and then discarded.</li> </ul> Relative serialized representation size of a flat stream of RDF triples or RDF quads, geometric mean over all datasets. N-Triples/N-Quads was used as the baseline (100%). <p>In flat streaming, the compression ratios for Jelly are almost identical to grouped streaming. This is also a case where RDF4J Binary has a comparable result to Jelly \u2013 it does well when serializing large batches of RDF triples/quads, because it maintains a large buffer of statements in the serializer. This means RDF4J is optimized for throughput \u2013 not latency. Jelly can do both, at the same time. Jena's binary formats have no in-built compression, and thus are much larger.</p>"},{"location":"performance/#flat-streaming-serialization-throughput","title":"Flat streaming serialization throughput","text":"<ul> <li>RiverBench task: <code>flat-serialization-throughput</code> (2.1.0)</li> <li>RiverBench profile: <code>flat-mixed-rdfstar</code> (2.1.0)</li> <li>The first 5,000,000 statements of each dataset were used for this benchmark.</li> <li>Each method/dataset combination was run 15 times, the first 5 runs were discarded to account for JVM warmup, and the remaining 10 runs were averaged.</li> <li>The data was preloaded into memory and serialized to a null output stream.</li> </ul> Serialization speed of a stream of RDF triples or quads, averaged over all datasets. <p>When reviewing these results, it's important to remember that Jelly is faster than Jena's binary formats, while also being much more compact \u2013 see serialized size results above.</p>"},{"location":"performance/#flat-streaming-deserialization-throughput","title":"Flat streaming deserialization throughput","text":"<ul> <li>RiverBench task: <code>flat-deserialization-throughput</code> (2.1.0)</li> <li>RiverBench profile: <code>flat-mixed-rdfstar</code> (2.1.0)</li> <li>The first 5,000,000 statements of each dataset were used for this benchmark.</li> <li>Each method/dataset combination was run 15 times, the first 5 runs were discarded to account for JVM warmup, and the remaining 10 runs were averaged.</li> <li>Before running the benchmark, the data was serialized to a single byte array and then deserialized from it. The deserializer was emitting only a stream of triples/quads, without any further processing.</li> </ul> Deserialization (parsing) speed of a stream of RDF triples or quads, averaged over all datasets."},{"location":"performance/#grouped-streaming-serialization-throughput","title":"Grouped streaming serialization throughput","text":"<ul> <li>RiverBench task: <code>stream-serialization-throughput</code> (2.1.0)</li> <li>RiverBench profile: <code>stream-mixed-rdfstar</code> (2.1.0)</li> <li>The first 100,000 stream elements of each dataset were used for this benchmark.</li> <li>Each method/dataset combination was run 15 times, the first 5 runs were discarded to account for JVM warmup, and the remaining 10 runs were averaged.</li> <li>The data was preloaded into memory and serialized to a null output stream.</li> </ul> Serialization speed of a stream of RDF graphs or RDF datasets, averaged over all datasets.* Partial results for RDF/XML and JSON-LD (some datasets not supported)."},{"location":"performance/#grouped-streaming-deserialization-throughput","title":"Grouped streaming deserialization throughput","text":"<ul> <li>RiverBench task: <code>stream-deserialization-throughput</code> (2.1.0)</li> <li>RiverBench profile: <code>stream-mixed-rdfstar</code> (2.1.0)</li> <li>The first 100,000 stream elements of each dataset were used for this benchmark.</li> <li>Each method/dataset combination was run 15 times, the first 5 runs were discarded to account for JVM warmup, and the remaining 10 runs were averaged.</li> <li>Before running the benchmark, the data was serialized to a list of byte arrays (one array per stream element) and then deserialized from it. The deserializer was emitting only a stream of triples/quads, without any further processing.</li> </ul> Deserialization (parsing) speed of a stream of RDF graphs or RDF datasets, averaged over all datasets.* Partial results for RDF/XML and JSON-LD (some datasets not supported)."},{"location":"performance/#see-also","title":"See also","text":"<ul> <li>Benchmarks with RDF4J</li> <li>Benchmark code</li> <li>RiverBench benchmark suite</li> <li>Jelly-JVM \u2013 the Jelly implementation used in the benchmarks</li> <li>User guide</li> </ul>"},{"location":"performance/rdf4j/","title":"RDF4J benchmarks","text":"<p>The following results were obtained by benchmarking Jelly-JVM against the N-Triples/N-Quads and RDF4J Binary serializations built into RDF4J.</p> <p>The benchmarks were performed on two kinds of RDF streams (according to the RDF-STaX taxonomy):</p> <ul> <li>Flat RDF streams \u2013 streams of RDF triples or quads. This is the \"classic\" serialization \u2013 equivalent to, for example N-Triples or N-Quads.</li> <li>Grouped RDF streams \u2013 streams of RDF graphs or datasets.</li> </ul> <p>Jelly has a major performance advantage especially in grouped RDF streams. This is mostly due to Jelly being the only tested serialization that natively supports grouped RDF streams. Because of this, Jelly can exploit the repeating terms, prefixes, and structures in the stream to achieve much better compression and serialization speed.</p> <p>If you are only interested in parsing/writing a single graph or dataset, look at the flat streaming results.</p>"},{"location":"performance/rdf4j/#benchmark-setup","title":"Benchmark setup","text":"<p>The same methodology was used as in the Apache Jena benchmarks, with the same datasets and the same setup. The benchmark was performed with Jelly-JVM 2.7.0 and RDF4J 5.1.2.</p>"},{"location":"performance/rdf4j/#results","title":"Results","text":"<p>Apache Jena performance results</p> <p>This page only shows supplementary performance results for RDF4J. More benchmarks (including the serialized representation size) with Jena can be found here: Apache Jena performance.</p> <p>Warning</p> <p>These results are NOT directly comparable with the performance results obtained on Jena. The two libraries have different APIs and internal data structures, which does affect the performance.</p> <p>The results can only be used to compare the performance within RDF4J.</p>"},{"location":"performance/rdf4j/#flat-streaming-serialization-throughput","title":"Flat streaming serialization throughput","text":"<ul> <li>RiverBench task: <code>flat-serialization-throughput</code> (2.1.0)</li> <li>RiverBench profile: <code>flat-mixed-rdfstar</code> (2.1.0)</li> <li>The first 5,000,000 statements of each dataset were used for this benchmark.</li> <li>Each method/dataset combination was run 15 times, the first 5 runs were discarded to account for JVM warmup, and the remaining 10 runs were averaged.</li> <li>The data was preloaded into memory and serialized to a null output stream.</li> </ul> Serialization speed of a stream of RDF triples or quads, averaged over all datasets. <p>Flat streaming serialization is admittedly the one scenario where Jelly is pretty close to RDF4J Binary in terms of performance. RDF4J Binary is very effective at serializing big batches of RDF triples/quads, because it maintains a large buffer of statements that wait in a queue before being serialized. This does result in very good throughput, but it also hurts the latency (which is in some cases relevant) and makes it less effective for smaller batches of statements. Jelly can universally fit both use cases \u2013 see the results for grouped streams below.</p>"},{"location":"performance/rdf4j/#flat-streaming-deserialization-throughput","title":"Flat streaming deserialization throughput","text":"<ul> <li>RiverBench task: <code>flat-deserialization-throughput</code> (2.1.0)</li> <li>RiverBench profile: <code>flat-mixed-rdfstar</code> (2.1.0)</li> <li>The first 5,000,000 statements of each dataset were used for this benchmark.</li> <li>Each method/dataset combination was run 15 times, the first 5 runs were discarded to account for JVM warmup, and the remaining 10 runs were averaged.</li> <li>Before running the benchmark, the data was serialized to a single byte array and then deserialized from it. The deserializer was emitting only a stream of triples/quads, without any further processing.</li> </ul> Deserialization (parsing) speed of a stream of RDF triples or quads, averaged over all datasets."},{"location":"performance/rdf4j/#grouped-streaming-serialization-throughput","title":"Grouped streaming serialization throughput","text":"<ul> <li>RiverBench task: <code>stream-serialization-throughput</code> (2.1.0)</li> <li>RiverBench profile: <code>stream-mixed-rdfstar</code> (2.1.0)</li> <li>The first 100,000 stream elements of each dataset were used for this benchmark.</li> <li>Each method/dataset combination was run 15 times, the first 5 runs were discarded to account for JVM warmup, and the remaining 10 runs were averaged.</li> <li>The data was preloaded into memory and serialized to a null output stream.</li> </ul> Serialization speed of a stream of RDF graphs or RDF datasets, averaged over all datasets."},{"location":"performance/rdf4j/#grouped-streaming-deserialization-throughput","title":"Grouped streaming deserialization throughput","text":"<ul> <li>RiverBench task: <code>stream-deserialization-throughput</code> (2.1.0)</li> <li>RiverBench profile: <code>stream-mixed-rdfstar</code> (2.1.0)</li> <li>The first 100,000 stream elements of each dataset were used for this benchmark.</li> <li>Each method/dataset combination was run 15 times, the first 5 runs were discarded to account for JVM warmup, and the remaining 10 runs were averaged.</li> <li>Before running the benchmark, the data was serialized to a list of byte arrays (one array per stream element) and then deserialized from it. The deserializer was emitting only a stream of triples/quads, without any further processing.</li> </ul> Deserialization (parsing) speed of a stream of RDF graphs or RDF datasets, averaged over all datasets."},{"location":"performance/rdf4j/#see-also","title":"See also","text":"<ul> <li>Benchmarks with Jena</li> <li>Benchmark code</li> <li>RiverBench benchmark suite</li> <li>Jelly-JVM \u2013 the Jelly implementation used in the benchmarks</li> <li>User guide</li> </ul>"},{"location":"specification/","title":"Jelly protocol specification","text":"<p>There are two Jelly-based serialization formats: Jelly-RDF for RDF data and Jelly-Patch for RDF patches (diffs). Additionally, there is the gRPC RDF streaming protocol defining an end-to-end mechanism for exchanging RDF data over the network.</p> <p>The following documents contain the formal specification of these formats and protocols, and are the \"ultimate source of truth\" for any implementations. See the user guide for a friendlier introduction to Jelly.</p> <p>See the specification pages for more details:</p> <ul> <li>Specification documents:<ul> <li>RDF serialization format specification \u2013 for serializing streams of RDF triples, quads, graphs, datasets.</li> <li>RDF Patch format specification \u2013 for serializing streams of changes to RDF data.</li> <li>gRPC RDF streaming protocol specification \u2013 for exchaning Jelly-RDF over the network.</li> </ul> </li> <li>Protobuf definitions:<ul> <li>Protobuf reference</li> <li>Protobuf sources</li> </ul> </li> <li>File extensions and media types</li> </ul>"},{"location":"specification/media-type/","title":"File extensions and media types","text":"<p>We recommend using these file extensions and media types when working with Jelly:</p> Format File extension Media type Jelly RDF serialization <code>.jelly</code> <code>application/x-jelly-rdf</code> Jelly Patch serialization <code>.jellyp</code> <code>application/x-jelly-rdf-patch</code> <p>The files should be saved in the delimited variant of Jelly.</p>"},{"location":"specification/media-type/#see-also","title":"See also","text":"<ul> <li>RDF serialization format specification</li> <li>Patch format specification</li> </ul>"},{"location":"specification/patch/","title":"Jelly RDF Patch format specification","text":"<p>Warning</p> <p>Jelly-Patch is in beta-testing phase and is not yet finalized. You are encouraged to try it out and let us know about any suggestions or bugs you found by opening an issue on GitHub.</p> <p>This document is the specification of the Jelly RDF Patch format, also known as Jelly-Patch. It is intended for implementers of Jelly libraries and applications. If you are looking for a user-friendly introduction to Jelly, see the Jelly index page.</p> <p>Info</p> <p>It is highly recommended to first read the RDF Patch specification. Jelly-Patch is an implementation of RDF Patch built on top of Jelly-RDF.</p> <p>This document is accompanied by the Jelly Protobuf reference and the Protobuf definition itself (<code>patch.proto</code>).</p> <p>The following assumptions are used in this document:</p> <ul> <li>The Jelly-Patch format is based on Jelly RDF serialization format, version <code>dev</code>. All concepts, definitions, and Protobuf messages defined there apply also here, unless explicitly stated otherwise.</li> <li>The basis for the terms used is the RDF 1.1 specification (W3C Recommendation 25 February 2014).</li> <li>Additionally, the RDF 1.1 Turtle specification (W3C Recommendation 25 February 2014) is used in parts as a basis for selected definitions.</li> <li>The RDF Patch specification document (RDF Delta, Andy Seaborne) is used as the basis for RDF Patch concepts and definitions.</li> <li>In parts referring to RDF-star, the RDF-star draft specification (W3C Community Group Draft Report 29 June 2023) is used. As the scope in which the RDF-star specification is used here is minimal, later versions of the specification are expected to be compatible with this document.</li> <li>All strings in the serialization are assumed to be UTF-8 encoded.</li> </ul> Document information Author: Piotr Sowi\u0144ski (Ostrzyciel) Version: experimental (dev) Date: July 30, 2025 Permanent URL: <code>https://w3id.org/jelly/dev/specification/patch</code> Document status: Experimental draft specification License: CC BY 4.0 <p>Info</p> <p>The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.</p> <p>Note</p> <p>The \"Note\" blocks in this document are not part of the specification, but rather provide additional information for implementers.</p> <p>Note</p> <p>The \"Example\" blocks in this document are not part of the specification, but rather provide informal examples of the serialization format.</p>"},{"location":"specification/patch/#conformance","title":"Conformance","text":"<p>Implementations MAY choose to implement only a subset of the following specification. In this case, they SHOULD clearly specify which parts of the specification they implement. In the rest of this specification, the keywords \"MUST\", \"MUST NOT\", etc. refer to full (not partial) implementations.</p> <p>Note</p> <p>Implementations may in particular choose to not implement features that are not supported on the target platform (e.g., RDF datasets, RDF-star, generalized RDF terms, etc.).</p> <p>Implementations MAY also choose to extend Jelly with additional features that SHOULD NOT interfere with the serialization being readable by implementations which follow the specification.</p>"},{"location":"specification/patch/#versioning","title":"Versioning","text":"<p>The protocol follows the Semantic Versioning 2.0 scheme. Each MAJOR.MINOR semantic version corresponds to an integer version tag in the protocol. The version tag is encoded in the <code>version</code> field of the <code>RdfPatchOptions</code> message. See also the section on patch stream options for more information on how to handle the version tags in serialized streams.</p> <p>The following versions of the protocol are defined:</p> Version tag Semantic version Last release date Changes 1 1.0.0 Not finalized yet (beta) (initial version) <p>Note</p> <p>Releases of the protocol are published on GitHub.</p>"},{"location":"specification/patch/#backward-compatibility","title":"Backward compatibility","text":"<p>Implementations SHOULD ensure backward compatibility. To achieve backward compatibility, the implementation MUST be able to read all messages from the previous releases of the protocol with the same MAJOR version. The implementation MAY also be able to read messages from previous releases of the protocol with a different MAJOR version.</p> <p>Note</p> <p>The protocol is designed in such a way that you don't need to worry about backward compatibility. The only thing you need to do is to implement the latest version of the protocol, and you will automatically get backward compatibility with all previous versions (of the same MAJOR).</p>"},{"location":"specification/patch/#forward-compatibility","title":"Forward compatibility","text":"<p>Forward compatibility is not guaranteed across different MINOR versions of the protocol. Implementations MAY be able to read messages from future releases of the protocol with the same MAJOR version. Implementations MAY also be able to read messages from future releases of the protocol with a different MAJOR version.</p> <p>New features introduced in PATCH versions of the protocol MUST NOT break forward compatibility.</p> <p>Note</p> <p>See also the notes about the practical implications of this in the Jelly-RDF specification.</p>"},{"location":"specification/patch/#actors-and-implementations","title":"Actors and implementations","text":"<p>Jelly-Patch assumes there to be two actors involved in processing the stream: the producer (serializer) and the consumer (parser). The producer is responsible for serializing the RDF Patch data into the Jelly-Patch format, and the consumer is responsible for parsing the Jelly-Patch format into RDF Patch data.</p> <p>Implementations may include only the producer, only the consumer, or both.</p>"},{"location":"specification/patch/#format-specification","title":"Format specification","text":"<p>Jelly-Patch uses Protocol Buffers version 3 as the underlying serialization format. All implementations MUST use a compliant Protocol Buffers implementation. The Protocol Buffers schema for Jelly-Patch is defined in <code>patch.proto</code> (source code, reference).</p> <p>The Jelly-Patch format describes a stream (i.e., and ordered sequence) of patch frames. The frames may be sent one-by-one using a dedicated streaming protocol (e.g., gRPC, MQTT, Kafka) or written in sequence to a byte stream (e.g., a file or socket). When writing multiple frames to a byte stream, the frames MUST be delimited \u2013 see the delimited variant.</p> <p>The semantics of the patch frames (i.e., how should the frames be interpreted) are decided by the patch stream type. The statements in the stream may be either RDF triples or quads, depending on the statement stream type. Jelly-Patch uses the same compression mechanisms as Jelly-RDF to compress the statements.</p>"},{"location":"specification/patch/#patch-frames","title":"Patch frames","text":"<p>A patch frame is a message of type <code>RdfPatchFrame</code> (reference). The message has a field <code>rows</code>, which is a repeated field of type <code>RdfPatchRow</code> (reference). A patch frame may contain any number of rows, however it is RECOMMENDED to keep the size of the frames below 1 MB. Unlike Jelly-RDF, Jelly-Patch defines specific semantics for the patch frames using patch stream types.</p>"},{"location":"specification/patch/#ordering","title":"Ordering","text":"<p>Patch frames MUST be processed strictly in order to preserve the semantics of the stream. Each patch frame MUST be processed in its entirety before the next patch frame is processed.</p> <p>Implementations MAY choose to adopt a non-standard solution where the order or delivery of the frames is not guaranteed and the stream can be read in more than one order or without some frames. The implementation MUST clearly specify in the documentation that it uses such a non-standard solution.</p> <p>Note</p> <p>See also the notes about the practical implications of this in the Jelly-RDF specification.</p>"},{"location":"specification/patch/#patch-rows","title":"Patch rows","text":"<p>A patch row is a message of type <code>RdfPatchRow</code> (reference). It MUST have exactly one of the following fields set:</p> <ul> <li><code>options</code> (1) \u2013 patch options header, indicating the patch stream type, statement type, compression options, and used RDF features.</li> <li><code>statement_add</code> (2) \u2013 adding an RDF statement operation. Row type in RDF Patch: <code>A</code>.</li> <li><code>statement_delete</code> (3) \u2013 deleting an RDF statement operation. Row type in RDF Patch: <code>D</code>.</li> <li><code>namespace_add</code> (4) \u2013 addding a namespace operation. Row type in RDF Patch: <code>PA</code>.</li> <li><code>namespace_delete</code> (5) \u2013 deleting a namespace operation. Row type in RDF Patch: <code>PD</code>.</li> <li><code>transaction_start</code> (6) \u2013 starting a transaction. Row type in RDF Patch: <code>TX</code>.</li> <li><code>transaction_commit</code> (7) \u2013 committing an ongoing transaction. Row type in RDF Patch: <code>TC</code>.</li> <li><code>transaction_abort</code> (8) \u2013 aborting an ongoing transaction. Row type in RDF Patch: <code>TA</code>.</li> <li><code>name</code> (11) \u2013 entry in the name lookup.</li> <li><code>prefix</code> (12) \u2013 entry in the prefix lookup.</li> <li><code>datatype</code> (13) \u2013 entry in the datatype lookup.</li> <li><code>header</code> (14) \u2013 RDF Patch header row. Row type in RDF Patch: <code>H</code>.</li> <li><code>punctuation</code> (15) \u2013 punctuation mark. It MUST NOT appear in streams of type other than <code>PUNCTUATED</code>.</li> </ul> <p>Fields 9 and 10 are reserved for future use.</p> <p>Fields 11, 12, 13 (lookup entries) do not correspond to any row type in RDF Patch. They are used by Jelly-Patch for compressing the IRIs and datatypes. Field 15 also does not correspond to any row type in RDF Patch. It is used for punctuation in the <code>PUNCTUATED</code> patch stream type, introduced by Jelly-Patch. Finally, field 1 is used for the patch options header, which is also specific to Jelly-Patch.</p> <p>The remaining fields (2, 3, 4, 5, 6, 7, 8, 14) correspond directly to the listed row types in RDF Patch and MUST be interpreted as such.</p>"},{"location":"specification/patch/#patch-stream-types","title":"Patch stream types","text":"<p>The patch stream type MUST be explicitly specified in the patch stream options. The patch stream type is defined by the <code>PatchStreamType</code> enum (reference). The following types are defined:</p> <ul> <li><code>PATCH_STREAM_TYPE_UNSPECIFIED</code> (0) \u2013 default value. This patch stream type MUST NOT be used. Consumers SHOULD throw an error if this value is used.</li> <li><code>PATCH_STREAM_TYPE_FRAME</code> (1) \u2013 every <code>RdfPatchFrame</code> message is a single, complete RDF Patch. In this stream type, transactions MUST NOT span multiple frames (see Transactions for details). The stream MUST NOT contain any <code>RdfPatchRow</code> messages with the <code>punctuation</code> field set.</li> <li><code>PATCH_STREAM_TYPE_FLAT</code> (2) \u2013 the entire stream is a single, complete RDF Patch. In this stream type, a transaction spanning multiple frames MUST be interpreted as a single transaction. The stream MUST NOT contain any <code>RdfPatchRow</code> messages with the <code>punctuation</code> field set.</li> <li><code>PATCH_STREAM_TYPE_PUNCTUATED</code> (3) \u2013 the stream is a sequence of RDF Patches, marked by punctuation marks (<code>RdfPatchPunctuation</code> message). The punctuation mark MUST occur at the end of an RDF Patch. The punctuation mark MUST NOT be used in any other context. <ul> <li>There are no additional restrictions on where the punctuation mark is placed within the frame. Therefore, it can be placed at the beginning, middle, or end of the frame.</li> </ul> </li> </ul> <p>Stream types</p> <p>The <code>FRAME</code> type is simple to use, but it requires you to fit the entire Patch inside a single frame. Because the contents of the frame are stored in memory as a whole, and because Protobuf implementations typically have strict limits on message sizes (~4 MB), this may not be possible for large patches. Therefore, we recommend using this stream type only if you are sure that the patches will always be small.</p> <p>The <code>FLAT</code> type is only appropriate if you want to store a single RDF patch in a byte stream.</p> <p><code>PUNCTUATED</code> is the most flexible type, decoupling frames from logical patches. It allows you to send multiple patches in a single stream, and it allows you to send patches that are larger than the maximum frame size.</p> <p>Punctuated streams</p> <p>Effectively, the punctuation mark must only be used to mark the end of an RDF Patch. So, if you start the stream with a punctuation mark, this would be interpreted as an empty RDF Patch.</p>"},{"location":"specification/patch/#statement-types","title":"Statement types","text":"<p>The statement type MUST be explicitly specified in the patch stream options. The statement type is defined by the <code>PatchStatementType</code> enum (reference). The following types are defined:</p> <ul> <li><code>STATEMENT_TYPE_UNSPECIFIED</code> (0) \u2013 default value. This statement type MUST NOT be used. Consumers SHOULD throw an error if this value is used.</li> <li><code>STATEMENT_TYPE_TRIPLES</code> (1) \u2013 in this case, the statements in the stream MUST be interpreted as RDF triples (graph is unspecified). The stream MUST NOT contain any <code>RdfQuad</code> or <code>RdfPatchNamespace</code> messages with the <code>graph</code> oneof set to any value.</li> <li><code>STATEMENT_TYPE_QUADS</code> (2) \u2013 in this case, the statements in the stream MUST be interpreted as RDF quads. If the <code>graph</code> oneof in the <code>RdfQuad</code> or <code>RdfPatchNamespace</code> message is not set, it MUST be interpreted as a repeated graph term, in line with the Jelly-RDF format specification.</li> </ul> <p>Note</p> <p>Statement types in Jelly-Patch work differently to Jelly-RDF's physical stream types. Instead of restricting which types of messages are valid in the stream, we always use <code>RdfQuad</code>, and the statement type option simply tells us how to interpret the messages.</p> <p>Note that in the RDF 1.1 spec there is a clear difference between a \"triple\" and a \"triple in the default graph\" which would be a quad. A \"triple\" does not specify which graph it belongs to \u2013 it may be the default graph, or it may be a named graph. In practice, only some RDF implementations make the distinction between a triple and a triple in the default graph (e.g., Apache Jena). Others, like Eclipse RDF4J always assume that the triple is in the default graph.</p>"},{"location":"specification/patch/#patch-stream-options","title":"Patch stream options","text":"<p>The patch stream options is a message of type <code>RdfPatchOptions</code> (reference). It MUST be the first row in the stream. It MAY appear more than once in the stream (also after other rows), but it MUST be identical to all previous occurrences. Consumers MAY throw an error if the patch stream options are not present at the start of the stream. Alternatively, they MAY use their own, implementation-specified default options. Consumers SHOULD NOT throw an error if the patch options are present more than once in the stream.</p> <p>The patch stream options instruct the consumer of the stream (parser) on the used patch stream type, statement type, compression options, and RDF features.</p> <p>The patch stream options message contains the following fields:</p> <ul> <li><code>statement_type</code> (1) \u2013 the statement type. This field is REQUIRED and it MUST be set to a value defined in the protocol other than <code>STATEMENT_TYPE_UNSPECIFIED</code>.</li> <li><code>stream_type</code> (2) \u2013 the patch stream type. This field is REQUIRED and it MUST be set to a value defined in the protocol other than <code>PATCH_STREAM_TYPE_UNSPECIFIED</code>.</li> <li><code>generalized_statements</code> (3) \u2013 whether the stream contains generalized RDF triples or graphs. This field MUST be set to true if the stream contains generalized RDF triples or graphs. It SHOULD NOT be set to true if the stream does not use this feature. This field is OPTIONAL and defaults to false.</li> <li><code>rdf_star</code> (4) \u2013 whether the stream uses RDF-star (quoted triples). This field MUST be set to true if the stream uses RDF-star. It SHOULD NOT be set to true if the stream does not use this feature. This field is OPTIONAL and defaults to false.</li> <li><code>max_name_table_size</code> (9) \u2013 maximum size of the name lookup. This field is REQUIRED and MUST be set to a value greater than or equal to 8. The size of the lookup MUST NOT exceed the value of this field.</li> <li><code>max_prefix_table_size</code> (10) \u2013 maximum size of the prefix lookup. This field is OPTIONAL and defaults to 0 (no lookup). If the field is set to 0, the prefix lookup MUST NOT be used in the stream. If the field is set to a positive value, the prefix lookup SHOULD be used in the stream and the size of the lookup MUST NOT exceed the value of this field.</li> <li><code>max_datatype_table_size</code> (11) \u2013 maximum size of the datatype lookup. This field is OPTIONAL and defaults to 0 (no lookup). If the field is set to 0, the datatype lookup MUST NOT be used in the stream (which effectively prohibits the use of datatype literals). If the field is set to a positive value, the datatype lookup SHOULD be used in the stream and the size of the lookup MUST NOT exceed the value of this field.</li> <li><code>version</code> (15) \u2013 version tag of the stream. This field is REQUIRED.<ul> <li>The version tag is encoded as a varint. The version tag MUST be greater than 0.</li> <li>The producer of the stream MUST set the version tag to the version tag of the protocol that was used to serialize the stream.</li> <li>It is RECOMMENDED that the producer uses the lowest possible version tag that is compatible with the features used in the stream.</li> <li>The consumer SHOULD throw an error if the version tag is greater than the version tag of the implementation.</li> <li>The consumer SHOULD throw an error if the version tag is zero.</li> <li>The consumer SHOULD NOT throw an error if the version tag is not zero but lower than the version tag of the implementation.</li> <li>The producer may use version tags greater than 10000 to indicate non-standard versions of the protocol.</li> </ul> </li> </ul>"},{"location":"specification/patch/#prefix-name-and-datatype-lookup-entries","title":"Prefix, name, and datatype lookup entries","text":"<p>Jelly-Patch uses the same IRI and datatype compression mechanism as Jelly-RDF. All rules specified for Jelly-RDF also apply here.</p>"},{"location":"specification/patch/#rdf-statements","title":"RDF statements","text":"<p>Add and delete operations on RDF statements (<code>A</code> and <code>D</code> in RDF Patch) are always encoded as <code>RdfQuad</code> messages (reference). The interpretation of <code>RdfQuad</code> messages depends on the statement type specified in the patch stream options:</p> <ul> <li><code>STATEMENT_TYPE_TRIPLES</code> \u2013 the <code>graph</code> oneof MUST NOT be set. If it is set, the consumer SHOULD ignore the graph term and MAY throw an error. The <code>RdfQuad</code> message MUST be interpreted as an RDF triple. The <code>subject</code>, <code>predicate</code>, and <code>object</code> oneofs MUST be set, unless a repeated term is used (see: Repeated terms).</li> <li><code>STATEMENT_TYPE_QUADS</code> \u2013 the <code>RdfQuad</code> message MUST be interpreted as an RDF quad. The <code>subject</code>, <code>predicate</code>, <code>object</code>, and <code>graph</code> oneofs MUST be set, unless a repeated term is used (see: Repeated terms).</li> </ul>"},{"location":"specification/patch/#repeated-terms","title":"Repeated terms","text":"<p>Jelly-Patch uses the same repeated term encoding as Jelly-RDF for <code>RdfQuad</code> messages. The only difference is in handling the <code>graph</code> oneof in streams with type <code>STATEMENT_TYPE_TRIPLES</code>, where the <code>graph</code> oneof MUST NOT be set and is not used for repeated term encoding.</p> <p>In Jelly-Patch, the type of the operation (add or delete) does not affect the repeated term encoding. An empty term in a <code>RdfQuad</code> message MUST be interpreted as a repeated term from the last <code>RdfQuad</code> or <code>RdfNamespaceDeclaration</code> (in case of <code>graph</code>) message in the stream, regardless of whether both operations are of the same type (add and add, or delete and delete) or not (add and delete, or delete and add).</p>"},{"location":"specification/patch/#namespaces","title":"Namespaces","text":"<p>Add and delete operations of namespace declarations (<code>PA</code> and <code>PD</code> in RDF Patch) are encoded as <code>RdfPatchNamespace</code> messages (reference). The <code>RdfPatchNamespace</code> message contains the following fields:</p> <ul> <li><code>name</code> (1) \u2013 the short name of the namespace, encoded in UTF-8. It SHOULD conform to the <code>PN_PREFIX</code> production in RDF 1.1 Turtle. Note that the <code>:</code> character (colon) is not part of the name. An empty string (the default value) is allowed.</li> <li><code>value</code> (2) \u2013 the IRI of the namespace as an <code>RdfIri</code> message. This field is REQUIRED for the namespace add operation (<code>PA</code>) and OPTIONAL for the namespace delete operation (<code>PD</code>).</li> <li><code>graph</code> oneof (3\u20136, fields <code>g_iri</code>, <code>g_bnode</code>, <code>g_default_graph</code>, <code>g_literal</code>) \u2013 the graph term of the namespace declaration.</li> </ul> <p>The <code>graph</code> oneof follows the Jelly-RDF graph node encoding. The <code>graph</code> oneof MUST NOT be set to any value in streams with type <code>STATEMENT_TYPE_TRIPLES</code>. In streams with type <code>STATEMENT_TYPE_QUADS</code>, the <code>graph</code> oneof MUST be set to one of the possible values, unless a repeated term is used (see: Repeated terms).</p> <p>In repeated term encoding, the <code>graph</code> oneof of <code>RdfPatchNamespace</code> MUST be interpreted in the same manner as if it appeared in a <code>RdfQuad</code> message. When <code>STREAM_TYPE_QUADS</code> is used and the <code>graph</code> oneof is not set to any value, it MUST be interpreted as a repeated graph term from the last <code>RdfQuad</code> or <code>RdfNamespaceDeclaration</code> message in the stream, regardless of whether both operations are of the same type (add and add, or delete and delete) or not (add and delete, or delete and add).</p> <p>Graph names in namespace declarations</p> <p>The original RDF Patch spec does not mention graph names in namespace declarations, but this feature is implemented in Apache Jena. This is useful for exact 1:1 RDF dataset replication in systems that store namespace mappings per graph, not per dataset.</p> <p>If your system does not support this, in <code>TRIPLES</code> streams you should simply ignore the graph name, and in <code>QUADS</code> streams, set it to <code>g_default_graph</code>.</p> <p>Repeated terms and namespace declarations</p> <p>In Jelly-Patch the type of the operation (add or delete) does not influence the repeated term encoding \u2013 in implementations you should use the same \"last term\" data structure for both. The same applies to the <code>graph</code> oneof in <code>RdfPatchNamespace</code> messages \u2013 its last value should be shared with quads.</p>"},{"location":"specification/patch/#transactions","title":"Transactions","text":"<p>Transaction operations (<code>TX</code>, <code>TC</code>, <code>TA</code> rows in RDF Patch) are encoded as <code>RdfPatchTransactionStart</code> (reference), <code>RdfPatchTransactionCommit</code> (reference), and <code>RdfPatchTransactionAbort</code> (reference) messages, respectively. Each of these messages defines no fields.</p> <p>Using transactions in the stream is OPTIONAL and the semantics of transactions are not defined by Jelly-Patch. Users are therefore free to use headers and operations on namespaces and statements within or outside of transactions, depending on their use case.</p> <p>Jelly-Patch restricts the syntax of transactions to the following:</p> <ul> <li>We define \"the previous transaction operation\" as the last encountered row in the stream until a given point with row type <code>transaction_start</code>, <code>transaction_commit</code> or <code>transaction_abort</code>. If there were no transaction operations in the stream until this point, the previous transaction operation is undefined.</li> <li>A row with a <code>transaction_commit</code> or <code>transaction_abort</code> operation MUST have a previous transaction operation equal to <code>transaction_start</code>. If there is no previous transaction operation, the consumer MAY throw an error. If there is a previous transaction operation that is a <code>transaction_commit</code> or <code>transaction_abort</code>, the consumer MAY throw an error.</li> <li>A row with a <code>transaction_start</code> operation MUST have a previous transaction operation that is either undefined or equal to <code>transaction_commit</code> or <code>transaction_abort</code>. If there is a previous transaction operation that is a <code>transaction_start</code>, the consumer MAY throw an error.</li> <li>A patch frame may contain multiple transactions, regardless of the used stream type.</li> <li>A transaction MUST start and commit/abort within one RDF Patch, regardless of the used patch stream type.<ul> <li>In <code>PATCH_STREAM_TYPE_FLAT</code> this puts no additional restrictions on transactions. Transactions may span multiple frames.</li> <li>In stream type <code>PATCH_STREAM_TYPE_FRAME</code>, transactions MUST NOT span multiple patch frames. The transaction start and commit/abort messages MUST be in the same frame.</li> <li>In <code>PATCH_STREAM_TYPE_PUNCTUATED</code> transactions may span multiple patch frames, but MUST NOT contain punctuation marks within their scope.</li> </ul> </li> </ul> <p>Transaction syntax and semantics</p> <p>Jelly-Patch only restricts the semantics of transactions, so that the only valid sequences of transaction operations are <code>TX ... TC</code> and <code>TX ... TA</code> \u2013 no nesting, no double-aborting, and no double-committing.</p> <p>The semantics of these operations are not defined by Jelly-Patch. RDF Patch contains more restrictions on transactions (e.g., headers must be at the beginning of the patch and outside the transaction), but these are not enforced by Jelly-Patch. The semantics are still not defined there, so you are free to use transactions in any way you like.</p>"},{"location":"specification/patch/#headers","title":"Headers","text":"<p>Headers (<code>H</code> row in RDF Patch) are encoded as <code>RdfPatchHeader</code> messages (reference). The <code>RdfPatchHeader</code> message contains the following fields:</p> <ul> <li><code>key</code> (1) \u2013 the key of the header, encoded in UTF-8. An empty string (the default value) is allowed.</li> <li><code>value</code> oneof (2\u20135, fields <code>h_iri</code>, <code>h_bnode</code>, <code>h_literal</code>, <code>h_triple_term</code>) \u2013 the value of the header. The value is encoded as an RDF term. The <code>value</code> oneof MUST be set to one of the possible values.</li> </ul> <p>Repeated term encoding MUST NOT be used for the <code>value</code> oneof in the <code>RdfPatchHeader</code> message (reference). The <code>value</code> oneof MUST always be set to a single value.</p>"},{"location":"specification/patch/#rdf-terms-and-graph-nodes","title":"RDF terms and graph nodes","text":"<p>Jelly-Patch uses the same RDF term and graph node encoding as Jelly-RDF.</p> <p>RDF term encoding is also used for the <code>h_iri</code>, <code>h_bnode</code>, <code>h_literal</code>, and <code>h_triple_term</code> fields in the <code>value</code> oneof of the <code>RdfPatchHeader</code> message (reference).</p> <p>RDF graph node encoding is also used for the <code>g_iri</code>, <code>g_bnode</code>, <code>g_default_graph</code>, and <code>g_literal</code> fields in the <code>graph</code> oneof of the <code>RdfPatchNamespace</code> message (reference). Additionally, RDF IRI encoding defined in Jelly-RDF is used for the <code>value</code> field in the <code>RdfPatchNamespace</code> message.</p> <p>The same rules about the order of processing RDF IRIs, RDF terms, RDF graph nodes, and their lookup references also apply here. The terms and graph nodes present in <code>RdfPatchHeader</code> and <code>RdfPatchNamespace</code> messages MUST be processed as if they were present in the <code>RdfQuad</code> messages, in the order in which their rows appear in the stream. In <code>RdfPatchNamespace</code>, the IRI in the <code>value</code> field MUST be processed before the RDF term in the <code>graph</code> oneof.</p> Example of RDF term encoding in Jelly-Patch (click to expand) <p>This basically means that you should treat terms in headers and namespaces in the same way as those in quad statements. The only difference is that for the <code>value</code> oneof in <code>RdfPatchHeader</code> there is no repeated term encoding, so it always must be set to some value.</p> <p>In this example the comments indicate equivalent RDF Patch rows in the stream, assuming the statement type is set to <code>STATEMENT_TYPE_QUADS</code>.</p> <pre><code># H id &lt;http://example.org/iri&gt;\nrows {\n    prefix {\n        id: 0 # default value, interpreted as 1\n        prefix: \"http://example.org/\"\n    }\n}\nrows {\n    name {\n        id: 0 # default value, interpreted as 1\n        name: \"iri\"\n    }\n}\nrows {\n    header {\n        h_iri {\n            prefix_id: 1\n            name_id: 0 # default value, interpreted as 1\n        }\n    }\n}\n\n# PA \"ex\" &lt;http://example.org/&gt; &lt;http://example.org/graph&gt; .\nrows {\n    name {\n        id: 0 # default value, interpreted as 1\n        name: \"\" # empty string\n    }\n}\nrows {\n    name {\n        id: 0 # default value, interpreted as 1\n        name: \"graph\"\n    }\n}\nrows {\n    namespace_add {\n        name: \"ex\"\n        value {\n            prefix_id: 0 # default value, interpreted as 1\n            name_id: 0 # default value, interpreted as 1+1=2\n            # because last name_id in h_iri was 0 interpreted as 1\n        }\n        g_iri {\n            prefix_id: 0 # default value, interpreted as 1\n            name_id: 0 # default value, interpreted as 2+1=3\n        }\n    }\n}\n\n# A _:b1 &lt;http://example.org/iri&gt; _:b2 &lt;http://example.org/graph&gt; .\nrows {\n    statement_add {\n        s_bnode: \"b1\"\n        p_iri {\n            prefix_id: 0 # default value, interpreted as 1\n            name_id: 1 # interpreted as 1\n        }\n        o_bnode: \"b2\"\n        # ((graph oneof not set))\n        # This is interpreted as repeating the graph term\n        # from the PA row above.\n    }\n}\n</code></pre>"},{"location":"specification/patch/#delimited-variant","title":"Delimited variant","text":"<p>A byte stream (or file) in the delimited variant MUST consist of a series of delimited <code>RdfPatchFrame</code> messages. A delimited message is a message that has a Protobuf varint prepended before it, specifying the length of the message in bytes.</p> <p>Note</p> <p>See also notes about the delimited variant in the Jelly-RDF specification.</p>"},{"location":"specification/patch/#internet-media-type-and-file-extension","title":"Internet media type and file extension","text":"<p>The RECOMMENDED media type for Jelly is <code>application/x-jelly-rdf-patch</code>. The RECOMMENDED file extension is <code>.jellyp</code>.</p> <p>The files SHOULD be saved in the delimited variant of Jelly-Patch.</p>"},{"location":"specification/patch/#security-considerations","title":"Security considerations","text":"<p>This section is not part of the specification.</p> <p>The same security considerations apply to Jelly-Patch as to Jelly-RDF. Please refer to the Jelly-RDF specification for more information.</p>"},{"location":"specification/patch/#implementations","title":"Implementations","text":"<p>This section is not part of the specification.</p> <p>The following implementations of the Jelly-Patch specification are available:</p> <ul> <li>Jelly-JVM implementation<ul> <li>Specification version: dev</li> <li>Implemented actors: producer, consumer</li> <li>Conformance: full</li> <li>Supported RDF libraries: Apache Jena, RDF4J</li> </ul> </li> </ul>"},{"location":"specification/protobuf-source/","title":"Protobuf sources","text":"<p>Below you will find the Protocol Buffers definitions for the Jelly-RDF and Jelly-Patch formats, along with the Jelly gRPC streaming protocol. The original files are hosted on GitHub and all releases can be found here.</p> <p>Human-readable reference for these definitions can be found here.</p> <p>The following code is licensed under the Apache License, Version 2.0.</p>"},{"location":"specification/protobuf-source/#rdfproto","title":"<code>rdf.proto</code>","text":"<pre><code>syntax = \"proto3\";\npackage eu.ostrzyciel.jelly.core.proto.v1;\n\n// Jelly RDF serialization with Protocol Buffers.\n// Specification document: \n// https://w3id.org/jelly/1.1.1/specification/serialization\n// Protocol version: 1.1.1\n\n// RDF IRIs\n// The IRIs are reconstructed by the consumer using the prefix and name\n// lookup tables.\nmessage RdfIri {\n  // 1-based, refers to an entry in the prefix lookup.\n  //\n  // 0 signifies \"use the same prefix_id as in the previous IRI\".\n  // For this to work, IRIs must be processed strictly in order: firstly by\n  // stream row, then by term (subject, predicate, object, graph). This also\n  // applies recursively to RDF-star quoted triples.\n  //\n  // If 0 appears in the first IRI of the stream (and in any subsequent IRI),\n  // this should be interpreted as an empty (\"\") prefix. This is for example\n  // used when the prefix lookup table is disabled.\n  uint32 prefix_id = 1;\n\n  // 1-based, refers to an entry in the name lookup.\n  //\n  // 0 signifies \"use the previous name_id + 1\". This requires the same order\n  // guarantees as prefixes.\n  //\n  // If 0 appears in the first IRI of the stream, it should be interpreted as\n  // name_id = 1.\n  uint32 name_id = 2;\n}\n\n// RDF literals\nmessage RdfLiteral {\n  // The lexical form of the literal (required).\n  string lex = 1;\n\n  // Literal kind \u2013 at most one of these field may be set.\n  // If none is set, then it's a simple literal.\n  oneof literalKind {\n    // Language-tagged string.\n    string langtag = 2;\n    // Typed literal. The datatype is a reference to an entry in the\n    // datatype lookup. This value is 1-based and the value of 0\n    // is invalid (in contrast to prefix_id and name_id in RdfIri).\n    uint32 datatype = 3;\n  }\n}\n\n// Empty message indicating the default RDF graph.\nmessage RdfDefaultGraph {\n}\n\n// RDF triple\n//\n// For each term (subject, predicate, object), the fields are repeated for\n// performance reasons. This is to avoid the need for boxing each term in a\n// separate message.\n//\n// Note: this message allows for representing generalized RDF triples (for\n// example, with literals as predicates). Whether this is used in the stream\n// is determined by the stream options (see RdfStreamOptions).\n//\n// If no field in a given oneof is set, the term is interpreted as a repeated\n// term \u2013 the same as the term in the same position in the previous triple.\n// In the first triple of the stream, all terms must be set.\n// All terms must also be set in quoted triples (RDF-star).\nmessage RdfTriple {\n  // Triple subject\n  oneof subject {\n    // IRI\n    RdfIri        s_iri = 1;\n    // Blank node\n    string        s_bnode = 2;\n    // Literal\n    // Only valid in a generalized RDF stream.\n    RdfLiteral    s_literal = 3;\n    // RDF-star quoted triple\n    RdfTriple     s_triple_term = 4;\n  }\n\n  // Triple predicate\n  oneof predicate {\n    // IRI\n    RdfIri        p_iri = 5;\n    // Blank node\n    // Only valid in a generalized RDF stream.\n    string        p_bnode = 6;\n    // Literal\n    // Only valid in a generalized RDF stream.\n    RdfLiteral    p_literal = 7;\n    // RDF-star quoted triple\n    RdfTriple     p_triple_term = 8;\n  }\n\n  // Triple object\n  oneof object {\n    // IRI\n    RdfIri        o_iri = 9;\n    // Blank node\n    string        o_bnode = 10;\n    // Literal\n    RdfLiteral    o_literal = 11;\n    // RDF-star quoted triple\n    RdfTriple     o_triple_term = 12;\n  }\n}\n\n// RDF quad\n//\n// Fields 1\u201312 are repeated from RdfTriple for performance reasons.\n//\n// Similarly to RdfTriple, this message allows for representing generalized\n// RDF quads (for example, with literals as predicates). Whether this is used\n// in the stream is determined by the stream options (see RdfStreamOptions).\n//\n// If no field in a given oneof is set, the term is interpreted as a repeated\n// term \u2013 the same as the term in the same position in the previous quad.\n// In the first quad of the stream, all terms must be set.\nmessage RdfQuad {\n  // Quad subject\n  oneof subject {\n    // IRI\n    RdfIri        s_iri = 1;\n    // Blank node\n    string        s_bnode = 2;\n    // Literal\n    // Only valid in a generalized RDF stream.\n    RdfLiteral    s_literal = 3;\n    // RDF-star quoted triple\n    RdfTriple     s_triple_term = 4;\n  }\n\n  // Quad predicate\n  oneof predicate {\n    // IRI\n    RdfIri        p_iri = 5;\n    // Blank node\n    // Only valid in a generalized RDF stream.\n    string        p_bnode = 6;\n    // Literal\n    // Only valid in a generalized RDF stream.\n    RdfLiteral    p_literal = 7;\n    // RDF-star quoted triple\n    RdfTriple     p_triple_term = 8;\n  }\n\n  // Quad object\n  oneof object {\n    // IRI\n    RdfIri        o_iri = 9;\n    // Blank node\n    string        o_bnode = 10;\n    // Literal\n    RdfLiteral    o_literal = 11;\n    // RDF-star quoted triple\n    RdfTriple     o_triple_term = 12;\n  }\n\n  // Quad graph\n  oneof graph {\n    // IRI\n    RdfIri           g_iri = 13;\n    // Blank node\n    string           g_bnode = 14;\n    // Default graph\n    RdfDefaultGraph  g_default_graph = 15;\n    // Literal \u2013 only valid for generalized RDF streams\n    RdfLiteral       g_literal = 16;\n  }\n}\n\n// Start of a graph in a GRAPHS stream\n//\n// In contrast to RdfQuad, setting the graph oneof to some value\n// is always required. No repeated terms are allowed.\nmessage RdfGraphStart {\n  oneof graph {\n    // IRI\n    RdfIri           g_iri = 1;\n    // Blank node\n    string           g_bnode = 2;\n    // Default graph\n    RdfDefaultGraph  g_default_graph = 3;\n    // Literal \u2013 only valid for generalized RDF streams\n    RdfLiteral       g_literal = 4;\n  }\n}\n\n// End of a graph in a GRAPHS stream\nmessage RdfGraphEnd {\n}\n\n// Explicit namespace declaration\n//\n// This does not correspond to any construct in the RDF Abstract Syntax.\n// Rather, it is a hint to the consumer that the given IRI prefix (namespace)\n// may be associated with a shorter name, like in Turtle syntax:\n// PREFIX ex: &lt;http://example.org/&gt;\n//\n// These short names (here \"ex:\") are NOT used in the RDF statement encoding.\n// This is a purely cosmetic feature useful in cases where you want to\n// preserve the namespace declarations from the original RDF document.\n// These declarations have nothing in common with the prefix lookup table.\nmessage RdfNamespaceDeclaration {\n  // Short name of the namespace (e.g., \"ex\")\n  // Do NOT include the colon.\n  string name = 1;\n  // IRI of the namespace (e.g., \"http://example.org/\")\n  RdfIri value = 2;\n}\n\n// Entry in the name lookup table\nmessage RdfNameEntry {\n  // 1-based identifier\n  // If id=0, it should be interpreted as previous_id + 1.\n  // If id=0 appears in the first RdfNameEntry of the stream, it should be\n  // interpreted as 1.\n  uint32 id = 1;\n  // Value of the name (UTF-8 encoded)\n  string value = 2;\n}\n\n// Entry in the prefix lookup table\n//\n// Note: the prefixes in the lookup table can be arbitrary strings, and are\n// NOT meant to be user-facing. They are only used for IRI compression.\n// To transmit user-facing namespace declarations for cosmetic purposes, use\n// RdfNamespaceDeclaration.\nmessage RdfPrefixEntry {\n  // 1-based identifier\n  // If id=0, it should be interpreted as previous_id + 1.\n  // If id=0 appears in the first RdfPrefixEntry of the stream, it should be\n  // interpreted as 1.\n  uint32 id = 1;\n  // Value of the prefix (UTF-8 encoded)\n  string value = 2;\n}\n\n// Entry in the datatype lookup table\nmessage RdfDatatypeEntry {\n  // 1-based identifier\n  // If id=0, it should be interpreted as previous_id + 1.\n  // If id=0 appears in the first RdfDatatypeEntry of the stream, it should be\n  // interpreted as 1.\n  uint32 id = 1;\n  // Value of the datatype (UTF-8 encoded)\n  string value = 2;\n}\n\n// RDF stream options\nmessage RdfStreamOptions {\n  // Name of the stream (completely optional).\n  // This may be used for, e.g., topic names in a pub/sub system.\n  string stream_name = 1;\n  // Type of the stream (required)\n  PhysicalStreamType physical_type = 2;\n  // Whether the stream may contain generalized triples, quads, or datasets\n  bool generalized_statements = 3;\n  // Whether the stream may contain RDF-star statements\n  bool rdf_star = 4;\n  // Maximum size of the name lookup table\n  // (required, must be &gt;= 8)\n  uint32 max_name_table_size = 9;\n  // Maximum size of the prefix lookup table\n  // (required if the prefix lookup is used)\n  uint32 max_prefix_table_size = 10;\n  // Maximum size of the datatype lookup table \n  // (required if datatype literals are used)\n  uint32 max_datatype_table_size = 11;\n  // Logical (RDF-STaX-based) stream type\n  // In contrast to the physical type, this field is entirely optional.\n  LogicalStreamType logical_type = 14;\n  // Protocol version (required)\n  // For Jelly 1.0.x value must be 1.\n  // For Jelly 1.1.x value must be 2.\n  // For custom extensions, the value must be 10000 or higher.\n  uint32 version = 15;\n}\n\n// Physical stream type\n// This determines how the data is encoded in the stream, not the logical\n// structure of the data. See LogicalStreamType for the latter.\nenum PhysicalStreamType {\n  // Unspecified stream type \u2013 invalid\n  PHYSICAL_STREAM_TYPE_UNSPECIFIED = 0;\n  // RDF triples\n  PHYSICAL_STREAM_TYPE_TRIPLES = 1;\n  // RDF quads\n  PHYSICAL_STREAM_TYPE_QUADS = 2;\n  // RDF triples grouped in graphs\n  PHYSICAL_STREAM_TYPE_GRAPHS = 3;\n}\n\n// Logical stream type, according to the RDF Stream Taxonomy (RDF-STaX).\n// Type 0 is reserved for the unspecified stream type.\n// The rest of the type numbers follow the taxonomical structure of RDF-STaX.\n// For example: 1 is a subtype of 0, 13 and 23 are subtypes of 3, \n// 114 is a subtype of 14, etc.\n// \n// Types 1\u20134 correspond to the four base concrete stream types. Their \n// subtypes can be in most cases simply processed in the same way as \n// the base types.\n// Therefore, implementations can take the modulo 10 of the stream \n// type to determine the base type of the stream and use this information \n// to select the appropriate processing logic.\n//\n// RDF-STaX version: 1.1.2\n// https://w3id.org/stax/1.1.2\n//\n// ^ The above URL is used to automatically determine the version of RDF-STaX\n// in the Jelly protocol specification. Please keep it up-to-date and in the\n// same format.\nenum LogicalStreamType {\n  // Unspecified stream type \u2013 invalid\n  LOGICAL_STREAM_TYPE_UNSPECIFIED = 0;\n  // Flat RDF triple stream\n  // https://w3id.org/stax/ontology#flatTripleStream\n  LOGICAL_STREAM_TYPE_FLAT_TRIPLES = 1;\n  // Flat RDF quad stream\n  // https://w3id.org/stax/ontology#flatQuadStream\n  LOGICAL_STREAM_TYPE_FLAT_QUADS = 2;\n  // RDF graph stream\n  // https://w3id.org/stax/ontology#graphStream\n  LOGICAL_STREAM_TYPE_GRAPHS = 3;\n  // RDF dataset stream\n  // https://w3id.org/stax/ontology#datasetStream\n  LOGICAL_STREAM_TYPE_DATASETS = 4;\n\n  // RDF subject graph stream (subtype of RDF graph stream)\n  // https://w3id.org/stax/ontology#subjectGraphStream\n  LOGICAL_STREAM_TYPE_SUBJECT_GRAPHS = 13;\n\n  // RDF named graph stream (subtype of RDF dataset stream)\n  // https://w3id.org/stax/ontology#namedGraphStream\n  LOGICAL_STREAM_TYPE_NAMED_GRAPHS = 14;\n  // RDF timestamped named graph stream (subtype of RDF dataset stream)\n  // https://w3id.org/stax/ontology#timestampedNamedGraphStream\n  LOGICAL_STREAM_TYPE_TIMESTAMPED_NAMED_GRAPHS = 114;\n}\n\n// RDF stream row\nmessage RdfStreamRow {\n  // Exactly one of these fields must be set.\n  oneof row {\n    // Stream options. Must occur at the start of the stream.\n    RdfStreamOptions options = 1;\n    // RDF triple statement.\n    // Valid in streams of physical type TRIPLES or GRAPHS.\n    RdfTriple triple = 2;\n    // RDF quad statement.\n    // Only valid in streams of physical type QUADS.\n    RdfQuad quad = 3;\n    // Graph boundary: ends the currently transmitted graph and starts a new one\n    // Only valid in streams of physical type GRAPHS.\n    RdfGraphStart graph_start = 4;\n    // Explicit end of a graph.\n    // Signals the consumer that the transmitted graph is complete.\n    // Only valid in streams of physical type GRAPHS.\n    RdfGraphEnd graph_end = 5;\n    // Explicit namespace declaration.\n    RdfNamespaceDeclaration namespace = 6;\n    // Entry in the name lookup table.\n    RdfNameEntry name = 9;\n    // Entry in the prefix lookup table.\n    RdfPrefixEntry prefix = 10;\n    // Entry in the datatype lookup table.\n    RdfDatatypeEntry datatype = 11;\n  }\n}\n\n// RDF stream frame \u2013 base message for RDF streams.\nmessage RdfStreamFrame {\n  // Stream rows\n  repeated RdfStreamRow rows = 1;\n  // Arbitrary metadata\n  // The keys are UTF-8 encoded strings, the values are byte arrays.\n  // This may be used by implementations in any way they see fit.\n  // The metadata does not affect the RDF data in any way, treat it\n  // as comments in a text file.\n  map&lt;string, bytes&gt; metadata = 15;\n}\n</code></pre>"},{"location":"specification/protobuf-source/#patchproto","title":"<code>patch.proto</code>","text":"<pre><code>syntax = \"proto3\";\npackage eu.ostrzyciel.jelly.core.proto.v1.patch;\n\n// EXPERIMENTAL FEATURE -- the API and format may change.\n\n// RDF Patch implementation based on Jelly\n// RDF Patch spec: https://afs.github.io/rdf-delta/rdf-patch.html\n// Jelly-Patch spec: https://w3id.org/jelly/1.1.0/specification/patch\n\nimport \"rdf.proto\";\n\nmessage RdfPatchTransactionStart {\n}\n\nmessage RdfPatchTransactionCommit {\n}\n\nmessage RdfPatchTransactionAbort {\n}\n\nmessage RdfPatchNamespace {\n  // Short name of the namespace (e.g., \"ex\")\n  // Do NOT include the colon.\n  string name = 1;\n  // IRI of the namespace (e.g., \"http://example.org/\").\n  // Optional in the \"prefix delete\" (PD) operation,\n  // but required in the \"prefix add\" (PA) operation.\n  RdfIri value = 2;\n  // Graph name for the namespace declaration.\n  //\n  // This is required for the statement type QUADS, and disallowed for\n  // the statement type TRIPLES.\n  //\n  // This is used to achieve full 1:1 replication in systems that associate\n  // namespaces with specific graphs (e.g., Apache Jena).\n  //\n  // Repeated term compression IS supported for this field.\n  // The repeated terms are shared between the namespace and statement rows.\n  oneof graph {\n    // IRI\n    RdfIri           g_iri = 3;\n    // Blank node\n    string           g_bnode = 4;\n    // Default graph\n    RdfDefaultGraph  g_default_graph = 5;\n    // Literal \u2013 only valid for generalized RDF streams\n    RdfLiteral       g_literal = 6;\n  }\n}\n\n// Metadata header for RDF Patch.\n// Header rows must occur at the start of the patch frame.\nmessage RdfPatchHeader {\n  // Header key (required)\n  string key = 1;\n  // Header value (required)\n  // Repeated term compression is not supported for header values.\n  // This oneof must always be set to a valid RDF term.\n  oneof value {\n    // IRI\n    RdfIri        h_iri = 2;\n    // Blank node\n    string        h_bnode = 3;\n    // Literal\n    RdfLiteral    h_literal = 4;\n    // RDF-star quoted triple\n    RdfTriple     h_triple_term = 5;\n  }\n}\n\nmessage RdfPatchPunctuation {\n}\n\n// RDF Patch stream options\nmessage RdfPatchOptions {\n  // Type of statements in the stream (required)\n  PatchStatementType statement_type = 1;\n  // Type of the stream (required)\n  PatchStreamType stream_type = 2;\n  // Whether the stream may contain generalized triples, quads, or datasets\n  bool generalized_statements = 3;\n  // Whether the stream may contain RDF-star statements\n  bool rdf_star = 4;\n  // Maximum size of the name lookup table\n  // (required, must be &gt;= 8)\n  uint32 max_name_table_size = 9;\n  // Maximum size of the prefix lookup table\n  // (required if the prefix lookup is used)\n  uint32 max_prefix_table_size = 10;\n  // Maximum size of the datatype lookup table\n  // (required if datatype literals are used)\n  uint32 max_datatype_table_size = 11;\n  // Protocol version (required)\n  // For Jelly-Patch 1.0.x (based on Jelly-RDF 1.1.x), the value must be 1.\n  // For custom extensions, the value must be 10000 or higher.\n  uint32 version = 15;\n}\n\n// Type of statements in the stream.\n// This determines whether the statements are interpreted as triples or quads.\nenum PatchStatementType {\n  // Unspecified stream type \u2013 invalid\n  PATCH_STATEMENT_TYPE_UNSPECIFIED = 0;\n  // RDF triples\n  PATCH_STATEMENT_TYPE_TRIPLES = 1;\n  // RDF quads\n  PATCH_STATEMENT_TYPE_QUADS = 2;\n}\n\n// Type of the stream.\n// This determines whether each RdfPatchFrame is a complete patch by itself,\n// or part of a larger patch.\nenum PatchStreamType {\n  // Unspecified stream type \u2013 invalid\n  PATCH_STREAM_TYPE_UNSPECIFIED = 0;\n  // Each RdfPatchFrame is a complete patch.\n  // In this case, transactions cannot span multiple frames.\n  PATCH_STREAM_TYPE_FRAME = 1;\n  // Entire stream is a single patch.\n  // Transactions may span multiple frames.\n  PATCH_STREAM_TYPE_FLAT = 2;\n  // Stream contains multiple patches separated by punctuation marks.\n  // Patches and transactions may span multiple frames.\n  // Each frame must contain at most one patch.\n  PATCH_STREAM_TYPE_PUNCTUATED = 3;\n}\n\n// A row in an RDF Patch stream\nmessage RdfPatchRow {\n  oneof row {\n    // Stream options. Must be the first row in the stream.\n    RdfPatchOptions options = 1;\n    // Add a triple/quad statement (A)\n    RdfQuad statement_add = 2;\n    // Delete a triple/quad statement (D)\n    RdfQuad statement_delete = 3;\n    // Add a namespace/prefix declaration (PA)\n    RdfPatchNamespace namespace_add = 4;\n    // Delete a namespace/prefix declaration (PD)\n    RdfPatchNamespace namespace_delete = 5;\n    // Transaction start (TX)\n    RdfPatchTransactionStart transaction_start = 6;\n    // Transaction commit (TC)\n    RdfPatchTransactionCommit transaction_commit = 7;\n    // Transaction abort (TA)\n    RdfPatchTransactionAbort transaction_abort = 8;\n    // Entry in the name lookup table.\n    RdfNameEntry name = 11;\n    // Entry in the prefix lookup table.\n    RdfPrefixEntry prefix = 12;\n    // Entry in the datatype lookup table.\n    RdfDatatypeEntry datatype = 13;\n    // Header entry (H)\n    RdfPatchHeader header = 14;\n    // Punctuation mark, only used in stream type PUNCTUATED\n    // Indicates the end of a patch.\n    RdfPatchPunctuation punctuation = 15;\n  }\n}\n\n// A batch of RDF patch rows.\nmessage RdfPatchFrame {\n  // Patch rows\n  repeated RdfPatchRow rows = 1;\n}\n</code></pre>"},{"location":"specification/protobuf-source/#grpcproto","title":"<code>grpc.proto</code>","text":"<pre><code>syntax = \"proto3\";\npackage eu.ostrzyciel.jelly.core.proto.v1;\n\n// Jelly gRPC streaming protocol.\n// Specification document: https://w3id.org/jelly/1.0.0/specification/streaming\n// Protocol version: 1.0.0\n\nimport \"rdf.proto\";\n\n// Subscribe command sent by the client to the server.\nmessage RdfStreamSubscribe {\n  // The topic to which the client wants to subscribe (UTF-8 encoded).\n  string topic = 1;\n  // Optional: the stream options requested by the client.\n  // The server should respond with a stream that matches these options.\n  // In case that is not possible, the server must respond with the\n  // INVALID_ARGUMENT error.\n  RdfStreamOptions requested_options = 2;\n}\n\n// Acknowledgement of receiving a stream sent by the server to the client.\nmessage RdfStreamReceived {\n}\n\n// Pub/Sub service for RDF streams, to be implemented by the server.\nservice RdfStreamService {\n  // Subscribe to an RDF stream.\n  rpc SubscribeRdf (RdfStreamSubscribe) returns (stream RdfStreamFrame);\n  // Publish an RDF stream.\n  // In case the server cannot process the stream, it must respond with\n  // the INVALID_ARGUMENT error.\n  rpc PublishRdf (stream RdfStreamFrame) returns (RdfStreamReceived);\n}\n</code></pre>"},{"location":"specification/protobuf-source/#see-also","title":"See also","text":"<ul> <li>Jelly Protobuf reference</li> <li>Jelly-RDF specification</li> <li>Jelly-Patch specification</li> <li>gRPC streaming protocol specification</li> </ul>"},{"location":"specification/reference/","title":"Protocol Documentation","text":""},{"location":"specification/reference/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>grpc.proto</p> <ul> <li>RdfStreamReceived</li> <li> <p>RdfStreamSubscribe</p> </li> <li> <p>RdfStreamService</p> </li> </ul> </li> <li> <p>patch.proto</p> <ul> <li>RdfPatchFrame</li> <li>RdfPatchHeader</li> <li>RdfPatchNamespace</li> <li>RdfPatchOptions</li> <li>RdfPatchPunctuation</li> <li>RdfPatchRow</li> <li>RdfPatchTransactionAbort</li> <li>RdfPatchTransactionCommit</li> <li> <p>RdfPatchTransactionStart</p> </li> <li> <p>PatchStatementType</p> </li> <li>PatchStreamType</li> </ul> </li> <li> <p>rdf.proto</p> <ul> <li>RdfDatatypeEntry</li> <li>RdfDefaultGraph</li> <li>RdfGraphEnd</li> <li>RdfGraphStart</li> <li>RdfIri</li> <li>RdfLiteral</li> <li>RdfNameEntry</li> <li>RdfNamespaceDeclaration</li> <li>RdfPrefixEntry</li> <li>RdfQuad</li> <li>RdfStreamFrame</li> <li>RdfStreamFrame.MetadataEntry</li> <li>RdfStreamOptions</li> <li>RdfStreamRow</li> <li> <p>RdfTriple</p> </li> <li> <p>LogicalStreamType</p> </li> <li>PhysicalStreamType</li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"specification/reference/#grpcproto","title":"grpc.proto","text":""},{"location":"specification/reference/#rdfstreamreceived","title":"RdfStreamReceived","text":"<p>Acknowledgement of receiving a stream sent by the server to the client.</p> <p></p>"},{"location":"specification/reference/#rdfstreamsubscribe","title":"RdfStreamSubscribe","text":"<p>Subscribe command sent by the client to the server.</p> Field Type Label Description topic string The topic to which the client wants to subscribe (UTF-8 encoded). requested_options RdfStreamOptions Optional: the stream options requested by the client. The server should respond with a stream that matches these options. In case that is not possible, the server must respond with the INVALID_ARGUMENT error. <p></p>"},{"location":"specification/reference/#rdfstreamservice","title":"RdfStreamService","text":"<p>Pub/Sub service for RDF streams, to be implemented by the server.</p> Method Name Request Type Response Type Description SubscribeRdf RdfStreamSubscribe RdfStreamFrame stream Subscribe to an RDF stream. PublishRdf RdfStreamFrame stream RdfStreamReceived Publish an RDF stream. In case the server cannot process the stream, it must respond with the INVALID_ARGUMENT error. <p></p> <p>Top</p>"},{"location":"specification/reference/#patchproto","title":"patch.proto","text":""},{"location":"specification/reference/#rdfpatchframe","title":"RdfPatchFrame","text":"<p>A batch of RDF patch rows.</p> Field Type Label Description rows RdfPatchRow repeated Patch rows <p></p>"},{"location":"specification/reference/#rdfpatchheader","title":"RdfPatchHeader","text":"<p>Metadata header for RDF Patch. Header rows must occur at the start of the patch frame.</p> Field Type Label Description key string Header key (required) h_iri eu.ostrzyciel.jelly.core.proto.v1.RdfIri IRI h_bnode string Blank node h_literal eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral Literal h_triple_term eu.ostrzyciel.jelly.core.proto.v1.RdfTriple RDF-star quoted triple <p></p>"},{"location":"specification/reference/#rdfpatchnamespace","title":"RdfPatchNamespace","text":"Field Type Label Description name string Short name of the namespace (e.g., \"ex\") Do NOT include the colon. value eu.ostrzyciel.jelly.core.proto.v1.RdfIri IRI of the namespace (e.g., \"http://example.org/\")..) Optional in the \"prefix delete\" (PD) operation, but required in the \"prefix add\" (PA) operation. g_iri eu.ostrzyciel.jelly.core.proto.v1.RdfIri IRI g_bnode string Blank node g_default_graph eu.ostrzyciel.jelly.core.proto.v1.RdfDefaultGraph Default graph g_literal eu.ostrzyciel.jelly.core.proto.v1.RdfLiteral Literal \u2013 only valid for generalized RDF streams"},{"location":"specification/reference/#rdfpatchoptions","title":"RdfPatchOptions","text":"<p>RDF Patch stream options</p> Field Type Label Description statement_type PatchStatementType Type of statements in the stream (required) stream_type PatchStreamType Type of the stream (required) generalized_statements bool Whether the stream may contain generalized triples, quads, or datasets rdf_star bool Whether the stream may contain RDF-star statements max_name_table_size uint32 Maximum size of the name lookup table (required, must be &gt;= 8) max_prefix_table_size uint32 Maximum size of the prefix lookup table (required if the prefix lookup is used) max_datatype_table_size uint32 Maximum size of the datatype lookup table (required if datatype literals are used) version uint32 Protocol version (required) For Jelly-Patch 1.0.x (based on Jelly-RDF 1.1.x), the value must be 1. For custom extensions, the value must be 10000 or higher. <p></p>"},{"location":"specification/reference/#rdfpatchpunctuation","title":"RdfPatchPunctuation","text":""},{"location":"specification/reference/#rdfpatchrow","title":"RdfPatchRow","text":"<p>A row in an RDF Patch stream</p> Field Type Label Description options RdfPatchOptions Stream options. Must be the first row in the stream. statement_add eu.ostrzyciel.jelly.core.proto.v1.RdfQuad Add a triple/quad statement (A) statement_delete eu.ostrzyciel.jelly.core.proto.v1.RdfQuad Delete a triple/quad statement (D) namespace_add RdfPatchNamespace Add a namespace/prefix declaration (PA) namespace_delete RdfPatchNamespace Delete a namespace/prefix declaration (PD) transaction_start RdfPatchTransactionStart Transaction start (TX) transaction_commit RdfPatchTransactionCommit Transaction commit (TC) transaction_abort RdfPatchTransactionAbort Transaction abort (TA) name eu.ostrzyciel.jelly.core.proto.v1.RdfNameEntry Entry in the name lookup table. prefix eu.ostrzyciel.jelly.core.proto.v1.RdfPrefixEntry Entry in the prefix lookup table. datatype eu.ostrzyciel.jelly.core.proto.v1.RdfDatatypeEntry Entry in the datatype lookup table. header RdfPatchHeader Header entry (H) punctuation RdfPatchPunctuation Punctuation mark, only used in stream type PUNCTUATED Indicates the end of a patch. <p></p>"},{"location":"specification/reference/#rdfpatchtransactionabort","title":"RdfPatchTransactionAbort","text":""},{"location":"specification/reference/#rdfpatchtransactioncommit","title":"RdfPatchTransactionCommit","text":""},{"location":"specification/reference/#rdfpatchtransactionstart","title":"RdfPatchTransactionStart","text":""},{"location":"specification/reference/#patchstatementtype","title":"PatchStatementType","text":"<p>Type of statements in the stream. This determines whether the statements are interpreted as triples or quads.</p> Name Number Description PATCH_STATEMENT_TYPE_UNSPECIFIED 0 Unspecified stream type \u2013 invalid PATCH_STATEMENT_TYPE_TRIPLES 1 RDF triples PATCH_STATEMENT_TYPE_QUADS 2 RDF quads <p></p>"},{"location":"specification/reference/#patchstreamtype","title":"PatchStreamType","text":"<p>Type of the stream. This determines whether each RdfPatchFrame is a complete patch by itself, or part of a larger patch.</p> Name Number Description PATCH_STREAM_TYPE_UNSPECIFIED 0 Unspecified stream type \u2013 invalid PATCH_STREAM_TYPE_FRAME 1 Each RdfPatchFrame is a complete patch. In this case, transactions cannot span multiple frames. PATCH_STREAM_TYPE_FLAT 2 Entire stream is a single patch. Transactions may span multiple frames. PATCH_STREAM_TYPE_PUNCTUATED 3 Stream contains multiple patches separated by punctuation marks. Patches and transactions may span multiple frames. Each frame must contain at most one patch. <p></p> <p>Top</p>"},{"location":"specification/reference/#rdfproto","title":"rdf.proto","text":""},{"location":"specification/reference/#rdfdatatypeentry","title":"RdfDatatypeEntry","text":"<p>Entry in the datatype lookup table</p> Field Type Label Description id uint32 1-based identifier If id=0, it should be interpreted as previous_id + 1. If id=0 appears in the first RdfDatatypeEntry of the stream, it should be interpreted as 1. value string Value of the datatype (UTF-8 encoded) <p></p>"},{"location":"specification/reference/#rdfdefaultgraph","title":"RdfDefaultGraph","text":"<p>Empty message indicating the default RDF graph.</p> <p></p>"},{"location":"specification/reference/#rdfgraphend","title":"RdfGraphEnd","text":"<p>End of a graph in a GRAPHS stream</p> <p></p>"},{"location":"specification/reference/#rdfgraphstart","title":"RdfGraphStart","text":"<p>Start of a graph in a GRAPHS stream</p> <p>In contrast to RdfQuad, setting the graph oneof to some value is always required. No repeated terms are allowed.</p> Field Type Label Description g_iri RdfIri IRI g_bnode string Blank node g_default_graph RdfDefaultGraph Default graph g_literal RdfLiteral Literal \u2013 only valid for generalized RDF streams <p></p>"},{"location":"specification/reference/#rdfiri","title":"RdfIri","text":"<p>RDF IRIs The IRIs are reconstructed by the consumer using the prefix and name lookup tables.</p> Field Type Label Description prefix_id uint32 1-based, refers to an entry in the prefix lookup. 0 signifies \"use the same prefix_id as in the previous IRI\". For this to work, IRIs must be processed strictly in order: firstly by stream row, then by term (subject, predicate, object, graph). This also applies recursively to RDF-star quoted triples. If 0 appears in the first IRI of the stream (and in any subsequent IRI), this should be interpreted as an empty (\"\") prefix. This is for example used when the prefix lookup table is disabled. name_id uint32 1-based, refers to an entry in the name lookup. 0 signifies \"use the previous name_id + 1\". This requires the same order guarantees as prefixes. If 0 appears in the first IRI of the stream, it should be interpreted as name_id = 1. <p></p>"},{"location":"specification/reference/#rdfliteral","title":"RdfLiteral","text":"<p>RDF literals</p> Field Type Label Description lex string The lexical form of the literal (required). langtag string Language-tagged string. datatype uint32 Typed literal. The datatype is a reference to an entry in the datatype lookup. This value is 1-based and the value of 0 is invalid (in contrast to prefix_id and name_id in RdfIri). <p></p>"},{"location":"specification/reference/#rdfnameentry","title":"RdfNameEntry","text":"<p>Entry in the name lookup table</p> Field Type Label Description id uint32 1-based identifier If id=0, it should be interpreted as previous_id + 1. If id=0 appears in the first RdfNameEntry of the stream, it should be interpreted as 1. value string Value of the name (UTF-8 encoded) <p></p>"},{"location":"specification/reference/#rdfnamespacedeclaration","title":"RdfNamespaceDeclaration","text":"<p>Explicit namespace declaration</p> <p>This does not correspond to any construct in the RDF Abstract Syntax. Rather, it is a hint to the consumer that the given IRI prefix (namespace) may be associated with a shorter name, like in Turtle syntax: PREFIX ex: &lt;http://example.org/&gt;</p> <p>These short names (here \"ex:\") are NOT used in the RDF statement encoding. This is a purely cosmetic feature useful in cases where you want to preserve the namespace declarations from the original RDF document. These declarations have nothing in common with the prefix lookup table.</p> Field Type Label Description name string Short name of the namespace (e.g., \"ex\") Do NOT include the colon. value RdfIri IRI of the namespace (e.g., \"http://example.org/\")) <p></p>"},{"location":"specification/reference/#rdfprefixentry","title":"RdfPrefixEntry","text":"<p>Entry in the prefix lookup table</p> <p>Note: the prefixes in the lookup table can be arbitrary strings, and are NOT meant to be user-facing. They are only used for IRI compression. To transmit user-facing namespace declarations for cosmetic purposes, use RdfNamespaceDeclaration.</p> Field Type Label Description id uint32 1-based identifier If id=0, it should be interpreted as previous_id + 1. If id=0 appears in the first RdfPrefixEntry of the stream, it should be interpreted as 1. value string Value of the prefix (UTF-8 encoded) <p></p>"},{"location":"specification/reference/#rdfquad","title":"RdfQuad","text":"<p>RDF quad</p> <p>Fields 1\u201312 are repeated from RdfTriple for performance reasons.</p> <p>Similarly to RdfTriple, this message allows for representing generalized RDF quads (for example, with literals as predicates). Whether this is used in the stream is determined by the stream options (see RdfStreamOptions).</p> <p>If no field in a given oneof is set, the term is interpreted as a repeated term \u2013 the same as the term in the same position in the previous quad. In the first quad of the stream, all terms must be set.</p> Field Type Label Description s_iri RdfIri IRI s_bnode string Blank node s_literal RdfLiteral Literal Only valid in a generalized RDF stream. s_triple_term RdfTriple RDF-star quoted triple p_iri RdfIri IRI p_bnode string Blank node Only valid in a generalized RDF stream. p_literal RdfLiteral Literal Only valid in a generalized RDF stream. p_triple_term RdfTriple RDF-star quoted triple o_iri RdfIri IRI o_bnode string Blank node o_literal RdfLiteral Literal o_triple_term RdfTriple RDF-star quoted triple g_iri RdfIri IRI g_bnode string Blank node g_default_graph RdfDefaultGraph Default graph g_literal RdfLiteral Literal \u2013 only valid for generalized RDF streams <p></p>"},{"location":"specification/reference/#rdfstreamframe","title":"RdfStreamFrame","text":"<p>RDF stream frame \u2013 base message for RDF streams.</p> Field Type Label Description rows RdfStreamRow repeated Stream rows metadata RdfStreamFrame.MetadataEntry repeated Arbitrary metadata The keys are UTF-8 encoded strings, the values are byte arrays. This may be used by implementations in any way they see fit. The metadata does not affect the RDF data in any way, treat it as comments in a text file. <p></p>"},{"location":"specification/reference/#rdfstreamframemetadataentry","title":"RdfStreamFrame.MetadataEntry","text":"Field Type Label Description key string value bytes"},{"location":"specification/reference/#rdfstreamoptions","title":"RdfStreamOptions","text":"<p>RDF stream options</p> Field Type Label Description stream_name string Name of the stream (completely optional). This may be used for, e.g., topic names in a pub/sub system. physical_type PhysicalStreamType Type of the stream (required) generalized_statements bool Whether the stream may contain generalized triples, quads, or datasets rdf_star bool Whether the stream may contain RDF-star statements max_name_table_size uint32 Maximum size of the name lookup table (required, must be &gt;= 8) max_prefix_table_size uint32 Maximum size of the prefix lookup table (required if the prefix lookup is used) max_datatype_table_size uint32 Maximum size of the datatype lookup table (required if datatype literals are used) logical_type LogicalStreamType Logical (RDF-STaX-based) stream type In contrast to the physical type, this field is entirely optional. version uint32 Protocol version (required) For Jelly 1.0.x value must be 1. For Jelly 1.1.x value must be 2. For custom extensions, the value must be 10000 or higher. <p></p>"},{"location":"specification/reference/#rdfstreamrow","title":"RdfStreamRow","text":"<p>RDF stream row</p> Field Type Label Description options RdfStreamOptions Stream options. Must occur at the start of the stream. triple RdfTriple RDF triple statement. Valid in streams of physical type TRIPLES or GRAPHS. quad RdfQuad RDF quad statement. Only valid in streams of physical type QUADS. graph_start RdfGraphStart Graph boundary: ends the currently transmitted graph and starts a new one Only valid in streams of physical type GRAPHS. graph_end RdfGraphEnd Explicit end of a graph. Signals the consumer that the transmitted graph is complete. Only valid in streams of physical type GRAPHS. namespace RdfNamespaceDeclaration Explicit namespace declaration. name RdfNameEntry Entry in the name lookup table. prefix RdfPrefixEntry Entry in the prefix lookup table. datatype RdfDatatypeEntry Entry in the datatype lookup table. <p></p>"},{"location":"specification/reference/#rdftriple","title":"RdfTriple","text":"<p>RDF triple</p> <p>For each term (subject, predicate, object), the fields are repeated for performance reasons. This is to avoid the need for boxing each term in a separate message.</p> <p>Note: this message allows for representing generalized RDF triples (for example, with literals as predicates). Whether this is used in the stream is determined by the stream options (see RdfStreamOptions).</p> <p>If no field in a given oneof is set, the term is interpreted as a repeated term \u2013 the same as the term in the same position in the previous triple. In the first triple of the stream, all terms must be set. All terms must also be set in quoted triples (RDF-star).</p> Field Type Label Description s_iri RdfIri IRI s_bnode string Blank node s_literal RdfLiteral Literal Only valid in a generalized RDF stream. s_triple_term RdfTriple RDF-star quoted triple p_iri RdfIri IRI p_bnode string Blank node Only valid in a generalized RDF stream. p_literal RdfLiteral Literal Only valid in a generalized RDF stream. p_triple_term RdfTriple RDF-star quoted triple o_iri RdfIri IRI o_bnode string Blank node o_literal RdfLiteral Literal o_triple_term RdfTriple RDF-star quoted triple <p></p>"},{"location":"specification/reference/#logicalstreamtype","title":"LogicalStreamType","text":"<p>Logical stream type, according to the RDF Stream Taxonomy (RDF-STaX). Type 0 is reserved for the unspecified stream type. The rest of the type numbers follow the taxonomical structure of RDF-STaX. For example: 1 is a subtype of 0, 13 and 23 are subtypes of 3,  114 is a subtype of 14, etc.</p> <p>Types 1\u20134 correspond to the four base concrete stream types. Their  subtypes can be in most cases simply processed in the same way as  the base types. Therefore, implementations can take the modulo 10 of the stream  type to determine the base type of the stream and use this information  to select the appropriate processing logic.</p> <p>RDF-STaX version: 1.1.2 https://w3id.org/stax/1.1.2</p> <p>^ The above URL is used to automatically determine the version of RDF-STaX in the Jelly protocol specification. Please keep it up-to-date and in the same format.</p> Name Number Description LOGICAL_STREAM_TYPE_UNSPECIFIED 0 Unspecified stream type \u2013 invalid LOGICAL_STREAM_TYPE_FLAT_TRIPLES 1 Flat RDF triple stream https://w3id.org/stax/ontology#flatTripleStream LOGICAL_STREAM_TYPE_FLAT_QUADS 2 Flat RDF quad stream https://w3id.org/stax/ontology#flatQuadStream LOGICAL_STREAM_TYPE_GRAPHS 3 RDF graph stream https://w3id.org/stax/ontology#graphStream LOGICAL_STREAM_TYPE_DATASETS 4 RDF dataset stream https://w3id.org/stax/ontology#datasetStream LOGICAL_STREAM_TYPE_SUBJECT_GRAPHS 13 RDF subject graph stream (subtype of RDF graph stream) https://w3id.org/stax/ontology#subjectGraphStream LOGICAL_STREAM_TYPE_NAMED_GRAPHS 14 RDF named graph stream (subtype of RDF dataset stream) https://w3id.org/stax/ontology#namedGraphStream LOGICAL_STREAM_TYPE_TIMESTAMPED_NAMED_GRAPHS 114 RDF timestamped named graph stream (subtype of RDF dataset stream) https://w3id.org/stax/ontology#timestampedNamedGraphStream <p></p>"},{"location":"specification/reference/#physicalstreamtype","title":"PhysicalStreamType","text":"<p>Physical stream type This determines how the data is encoded in the stream, not the logical structure of the data. See LogicalStreamType for the latter.</p> Name Number Description PHYSICAL_STREAM_TYPE_UNSPECIFIED 0 Unspecified stream type \u2013 invalid PHYSICAL_STREAM_TYPE_TRIPLES 1 RDF triples PHYSICAL_STREAM_TYPE_QUADS 2 RDF quads PHYSICAL_STREAM_TYPE_GRAPHS 3 RDF triples grouped in graphs"},{"location":"specification/reference/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"specification/serialization/","title":"Jelly RDF serialization format specification","text":"<p>This document is the specification of the Jelly RDF serialization format, also known as Jelly-RDF. It is intended for implementers of Jelly libraries and applications. If you are looking for a user-friendly introduction to Jelly, see the Jelly index page.</p> <p>This document is accompanied by the Jelly Protobuf reference and the Protobuf definition itself (<code>rdf.proto</code>).</p> <p>The following assumptions are used in this document:</p> <ul> <li>The basis for the terms used is the RDF 1.1 specification (W3C Recommendation 25 February 2014).</li> <li>Additionally, the RDF 1.1 Turtle specification (W3C Recommendation 25 February 2014) is used in parts as a basis for selected definitions.</li> <li>In parts referring to RDF-star, the RDF-star draft specification (W3C Community Group Draft Report 29 June 2023) is used. As the scope in which the RDF-star specification is used here is minimal, later versions of the specification are expected to be compatible with this document.</li> <li>In parts referring to the RDF Stream Taxonomy (RDF-STaX), the RDF-STaX version 1.1.2 ontology and taxonomy are used.</li> <li>All strings in the serialization are assumed to be UTF-8 encoded.</li> </ul> Document information Author: Piotr Sowi\u0144ski (Ostrzyciel) Version: dev Date: June 12, 2025 Permanent URL: <code>https://w3id.org/jelly/dev/specification/serialization</code> Document status: Draft specification License: CC BY 4.0 <p>Info</p> <p>The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.</p> <p>Note</p> <p>The \"Note\" blocks in this document are not part of the specification, but rather provide additional information for implementers.</p> <p>Note</p> <p>The \"Example\" blocks in this document are not part of the specification, but rather provide informal examples of the serialization format.</p>"},{"location":"specification/serialization/#conformance","title":"Conformance","text":"<p>Implementations MAY choose to implement only a subset of the following specification. In this case, they SHOULD clearly specify which parts of the specification they implement. In the rest of this specification, the keywords \"MUST\", \"MUST NOT\", etc. refer to full (not partial) implementations.</p> <p>Note</p> <p>Implementations may in particular choose to not implement features that are not supported on the target platform (e.g., RDF datasets, RDF-star, generalized RDF terms, etc.).</p> <p>Implementations MAY also choose to extend Jelly with additional features that SHOULD NOT interfere with the serialization being readable by implementations which follow the specification.</p>"},{"location":"specification/serialization/#versioning","title":"Versioning","text":"<p>The protocol follows the Semantic Versioning 2.0 scheme. Each MAJOR.MINOR semantic version corresponds to an integer version tag in the protocol. The version tag is encoded in the <code>version</code> field of the <code>RdfStreamOptions</code> message. See also the section on stream options for more information on how to handle the version tags in serialized streams.</p> <p>The following versions of the protocol are defined:</p> Version tag Semantic version Release date Changes 1 1.0.x August 24, 2024 (initial version) 2 1.1.0 December 21, 2024 Added <code>RdfNamespaceDeclaration</code> 2 1.1.1 March 10, 2025 Added <code>RdfStreamFrame.metadata</code> 2 1.1.2 June 12, 2025 Bugfixes: #35, #43, #44 2 1.1.3 (current) June 12, 2025 (in development) <p>Note</p> <p>Releases of the protocol are published on GitHub.</p>"},{"location":"specification/serialization/#backward-compatibility","title":"Backward compatibility","text":"<p>Implementations SHOULD ensure backward compatibility. To achieve backward compatibility, the implementation MUST be able to read all messages from the previous releases of the protocol with the same MAJOR version. The implementation MAY also be able to read messages from previous releases of the protocol with a different MAJOR version.</p> <p>Note</p> <p>The protocol is designed in such a way that you don't need to worry about backward compatibility. The only thing you need to do is to implement the latest version of the protocol, and you will automatically get backward compatibility with all previous versions (of the same MAJOR).</p>"},{"location":"specification/serialization/#forward-compatibility","title":"Forward compatibility","text":"<p>Forward compatibility is not guaranteed across different MINOR versions of the protocol. Implementations MAY be able to read messages from future releases of the protocol with the same MAJOR version. Implementations MAY also be able to read messages from future releases of the protocol with a different MAJOR version.</p> <p>New features introduced in PATCH versions of the protocol MUST NOT break forward compatibility.</p> <p>Note</p> <p>In practical terms, new MINOR versions of the protocol usually introduce new types of messages that previous implementations do not know how to handle. As long as the producer does not use the new messages in the stream, consumers implementing the previous protocol version will be able to read the stream.</p> <p>However, implementations will generally refuse to read a stream that is marked as using a higher protocol version than they support (see: stream options: <code>version</code> field). If you, as a producer, do not intend to use the new features of the protocol, we recommend you mark the stream with the lowest applicable version (see the version table above for a correspondence between features and versions). This way, older implementations will be able to read the stream.</p> <p>Forward-compatible features</p> <p>Protobuf allows for adding new fields to messages without breaking compatibility with older implementations \u2013 they will simply ignore the new field. An example of this is the <code>metadata</code> field in the <code>RdfStreamFrame</code> message, which was added in version 1.1.1. Implementations of version 1.1.0 will ignore it.</p>"},{"location":"specification/serialization/#actors-and-implementations","title":"Actors and implementations","text":"<p>Jelly-RDF assumes there to be two actors involved in processing the stream: the producer (serializer) and the consumer (parser). The producer is responsible for serializing the RDF data into the Jelly format, and the consumer is responsible for parsing the Jelly format into RDF data.</p> <p>Implementations may include only the producer, only the consumer, or both.</p>"},{"location":"specification/serialization/#format-specification","title":"Format specification","text":"<p>The Jelly RDF serialization format uses Protocol Buffers version 3 as the underlying serialization format. All implementations MUST use a compliant Protocol Buffers implementation. The Protocol Buffers schema for Jelly serialization is defined in <code>rdf.proto</code> (source code, reference).</p> <p>The Jelly-RDF format describes a stream (i.e., an ordered sequence) of stream frames. The frames may be sent one-by-one using a dedicated streaming protocol (e.g., gRPC, MQTT, Kafka) or written in sequence to a byte stream (e.g., a file or socket). When writing multiple frames to a byte stream, the frames MUST be delimited \u2013 see the delimited variant.</p> <p>Jelly supports several distinct physical types of streams, and uses a simple and configurable compression mechanism using lookup tables.</p>"},{"location":"specification/serialization/#stream-frames","title":"Stream frames","text":"<p>A stream frame is a message of type <code>RdfStreamFrame</code> (reference). The message has a field <code>rows</code>, which is a repeated field of type <code>RdfStreamRow</code> (reference). A stream frame may contain any number of rows, however it is RECOMMENDED to keep the size of the frames below 1 MB. The semantics for the frames are not defined by the protocol. The end users are free to define their own semantics for the frames.</p> <p>Note</p> <p>A stream frame in \"simple flat file\" is just a batch of RDF statements \u2013 the stream frames may carry no semantics in this case. You can make the stream frame as long as the file itself, but this is not recommended, as it would make the file harder to process.</p> <p>Note</p> <p>Stream frames can also be used to indicate individual stream elements. For example, in the case of a stream of RDF datasets, each frame may contain one dataset. RiverBench datasets use this convention in their distributions.</p>"},{"location":"specification/serialization/#ordering","title":"Ordering","text":"<p>Stream frames MUST be processed strictly in order to preserve the semantics of the stream. Each stream frame MUST be processed in its entirety before the next stream frame is processed.</p> <p>Implementations MAY choose to adopt a non-standard solution where the order or delivery of the frames is not guaranteed and the stream can be read in more than one order or without some frames. The implementation MUST clearly specify in the documentation that it uses such a non-standard solution.</p> <p>Note</p> <p>An example where not adhering to the strict ordering may be useful is when you are dealing with a network streaming protocol that does not guarantee the order of the messages (e.g., MQTT).</p> <p>Note</p> <p>The main thing you will need to worry about is the order of the lookup tables. If you can, emit all lookup tables at the beginning of the stream. When using stream partitions (e.g., in Kafka), you should ensure that the lookups are emitted to each partition. Alternatively, you can transmit the lookup tables separately from the stream.</p>"},{"location":"specification/serialization/#stream-frame-metadata","title":"Stream frame metadata","text":"<p>Since protocol version 1.1.1, <code>RdfStreamFrame</code> messages have a <code>metadata</code> field of type <code>map&lt;string, bytes&gt;</code>. This field is OPTIONAL and does not influence the processing of RDF data in any manner. The keys and values in the map are arbitrary and implementation-defined.</p> <p>Consumers SHOULD ignore unknown keys in the metadata map. Consumers also SHOULD validate the values in the metadata map to ensure that they follow the expected format. Consumers MUST NOT assume that values are character strings or that they are valid UTF-8.</p> <p>Note</p> <p>The metadata field is intended for use cases where additional information about the stream frame must be attached directly to the stream, but not as part of the RDF stream itself. For example, you could use it to store the timestamp of the frame, its unique identifier, hash code, or anything else relevant to your use case.</p> <p>You can use the metadata to store UTF-8 strings, numbers, or even nested protobuf messages. Because of this, you should never assume that the value is a valid string. Always validate the value before using it.</p>"},{"location":"specification/serialization/#stream-rows","title":"Stream rows","text":"<p>A stream row is a message of type <code>RdfStreamRow</code>. It MUST have exactly one of the following fields set:</p> <ul> <li><code>options</code> (1) \u2013 stream options header, indicating the compression options and the used RDF features in the stream.</li> <li><code>triple</code> (2) \u2013 RDF triple statement. It MUST NOT appear in streams of type other than <code>PHYSICAL_STREAM_TYPE_TRIPLES</code> or <code>PHYSICAL_STREAM_TYPE_GRAPHS</code>.</li> <li><code>quad</code> (3) \u2013 RDF quad statement. It MUST NOT appear in streams of type other than <code>PHYSICAL_STREAM_TYPE_QUADS</code>.</li> <li><code>graph_start</code> (4) \u2013 indicates the start of a graph (named or default). It MUST NOT appear in streams of type other than <code>PHYSICAL_STREAM_TYPE_GRAPHS</code>.</li> <li><code>graph_end</code> (5) \u2013 indicates the end of a graph (named or default). It MUST NOT appear in streams of type other than <code>PHYSICAL_STREAM_TYPE_GRAPHS</code>.</li> <li><code>namespace</code> (6) \u2013 namespace declaration. It may appear in any stream type.</li> <li><code>name</code> (9) \u2013 entry in the name lookup.</li> <li><code>prefix</code> (10) \u2013 entry in the prefix lookup.</li> <li><code>datatype</code> (11) \u2013 entry in the datatype lookup.</li> </ul> <p>Stream rows MUST be processed strictly in order to preserve the semantics of the stream.</p>"},{"location":"specification/serialization/#physical-stream-types","title":"Physical stream types","text":"<p>The physical type of the stream MUST be explicitly specified in the stream options header. The physical type of the stream is defined by the <code>PhysicalStreamType</code> enum (reference). The following types are defined:</p> <ul> <li><code>PHYSICAL_STREAM_TYPE_UNSPECIFIED</code> (0) \u2013 default value. This physical stream type MUST NOT be used. Consumers SHOULD throw an error if this value is used.</li> <li><code>PHYSICAL_STREAM_TYPE_TRIPLES</code> (1) \u2013 stream of RDF triple statements. In this case, the stream MUST NOT contain <code>RdfStreamRow</code> messages with the <code>quad</code>, <code>graph_start</code>, or <code>graph_end</code> fields set.</li> <li><code>PHYSICAL_STREAM_TYPE_QUADS</code> (2) \u2013 stream of RDF quad statements (same as simple statements in N-Quads). In this case, the stream MUST NOT contain <code>RdfStreamRow</code> messages with the <code>triple</code>, <code>graph_start</code>, or <code>graph_end</code> fields set.</li> <li><code>PHYSICAL_STREAM_TYPE_GRAPHS</code> (3) \u2013 stream of RDF graphs (named or default). In this case, the stream MUST NOT contain <code>RdfStreamRow</code> messages with the <code>quad</code> fields set.</li> </ul> <p>Note</p> <p>See also a more human explanation of the available physical stream types.</p> <p>Note</p> <p>The physical stream type only specifies how the data is encoded, not how it should be interpreted. See the logical stream types for a mechanism to specify the semantics of the stream.</p>"},{"location":"specification/serialization/#logical-stream-types","title":"Logical stream types","text":"<p>Specifying the logical stream type in the stream options header is OPTIONAL. When it is specified, the implementations MAY use it to determine the semantics of the stream. The implementations also MAY ignore the specified logical stream type and interpret the stream in any other manner. The logical stream type is defined by the <code>LogicalStreamType</code> enum (reference).</p> <p>This version of Jelly uses the RDF Stream Taxonomy (RDF-STaX) 1.1.2 and implements all stream types of RDF-STaX as logical stream types. The following logical stream types are defined:</p> <ul> <li><code>LOGICAL_STREAM_TYPE_UNSPECIFIED</code> (0) \u2013 default value. This logical stream type is used when the serializer chooses not to specify the logical stream type.</li> <li><code>LOGICAL_STREAM_TYPE_FLAT_TRIPLES</code> (1)<ul> <li>RDF-STaX name: Flat RDF triple stream</li> <li>RDF-STaX IRI: <code>https://w3id.org/stax/ontology#flatTripleStream</code></li> </ul> </li> <li><code>LOGICAL_STREAM_TYPE_FLAT_QUADS</code> (2)<ul> <li>RDF-STaX name: Flat RDF quad stream</li> <li>RDF-STaX IRI: <code>https://w3id.org/stax/ontology#flatQuadStream</code></li> </ul> </li> <li><code>LOGICAL_STREAM_TYPE_GRAPHS</code> (3)<ul> <li>RDF-STaX name: RDF graph stream</li> <li>RDF-STaX IRI: <code>https://w3id.org/stax/ontology#graphStream</code></li> </ul> </li> <li><code>LOGICAL_STREAM_TYPE_DATASETS</code> (4)<ul> <li>RDF-STaX name: RDF dataset stream</li> <li>RDF-STaX IRI: <code>https://w3id.org/stax/ontology#datasetStream</code></li> </ul> </li> <li><code>LOGICAL_STREAM_TYPE_SUBJECT_GRAPHS</code> (13)<ul> <li>RDF-STaX name: RDF subject graph stream</li> <li>RDF-STaX IRI: <code>https://w3id.org/stax/ontology#subjectGraphStream</code></li> <li>Subtype of: <code>LOGICAL_STREAM_TYPE_GRAPHS</code> (3)</li> </ul> </li> <li><code>LOGICAL_STREAM_TYPE_NAMED_GRAPHS</code> (14)<ul> <li>RDF-STaX name: RDF named graph stream</li> <li>RDF-STaX IRI: <code>https://w3id.org/stax/ontology#namedGraphStream</code></li> <li>Subtype of: <code>LOGICAL_STREAM_TYPE_DATASETS</code> (4)</li> </ul> </li> <li><code>LOGICAL_STREAM_TYPE_TIMESTAMPED_NAMED_GRAPHS</code> (114)<ul> <li>RDF-STaX name: Timestamped RDF named graph stream</li> <li>RDF-STaX IRI: <code>https://w3id.org/stax/ontology#timestampedNamedGraphStream</code></li> <li>Subtype of: <code>LOGICAL_STREAM_TYPE_NAMED_GRAPHS</code> (14)</li> </ul> </li> </ul>"},{"location":"specification/serialization/#version-compatibility-and-base-types","title":"Version compatibility and base types","text":"<p>In all Jelly versions 1.x.y there MUST be the same four base logical stream types (numbered 1, 2, 3, 4). The remaining logical stream types (with numbers greater than 10) may change between releases in the 1.x.y family, following the versioning rules. The four base types (1\u20134) are thus fixed, enabling forward compatibility for implementations that only support the base types.</p> <p>Each remaining logical stream type is a subtype of a base type (including recursive subtyping). To determine the base type of a logical stream type, the implementation MUST take the last digit of the logical stream type number, which is equivalent to the modulo 10 operation. Implementations MAY choose to treat a subtype of a base type in the same manner as the base type itself.</p> Example (click to expand) <p>The base type of <code>LOGICAL_STREAM_TYPE_NAMED_GRAPHS</code> (14) is <code>LOGICAL_STREAM_TYPE_DATASETS</code> (4).</p> <p>The base type of <code>LOGICAL_STREAM_TYPE_TIMESTAMPED_NAMED_GRAPHS</code> (114) is <code>LOGICAL_STREAM_TYPE_DATASETS</code> (4).</p> <p>The base type of <code>LOGICAL_STREAM_TYPE_FLAT_TRIPLES</code> (1) is <code>LOGICAL_STREAM_TYPE_FLAT_TRIPLES</code> (1).</p> <p>Note</p> <p>In practice, the base logical stream types (1\u20134) are the most important part, determining how the data should be shaped and processed. The other logical stream types are used to provide additional information about the stream. If you are implementing a streaming serializer/deserializer, you should focus on the base types and treat their subtypes in the same way. So, do a modulo 10 on the stream type and you are good to go.</p>"},{"location":"specification/serialization/#consistency-with-physical-stream-types","title":"Consistency with physical stream types","text":"<p>Implementations MAY choose to use the logical stream type to determine how to interpret the stream. In that case, the implementation SHOULD ensure that the logical stream type is consistent with the physical stream type in the sense that the implementation supports this combination of stream types. If the logical stream type is inconsistent with the physical stream type, the implementation MAY throw an error.</p> <p>The following table shows the RECOMMENDED support matrix for the logical stream types and physical stream types, along with the RECOMMENDED manner in which the stream should be interpreted:</p> RDF-STaX (logical type) / Physical type <code>TRIPLES</code> <code>QUADS</code> <code>GRAPHS</code> <code>LOGICAL_STREAM_TYPE_GRAPHS</code> Framed \u2718 \u2718 <code>LOGICAL_STREAM_TYPE_SUBJECT_GRAPHS</code> Framed \u2718 \u2718 <code>LOGICAL_STREAM_TYPE_DATASETS</code> \u2718 Framed Framed <code>LOGICAL_STREAM_TYPE_NAMED_GRAPHS</code> \u2718 Framed Framed <code>LOGICAL_STREAM_TYPE_TIMESTAMPED_NAMED_GRAPHS</code> \u2718 Framed Framed <code>LOGICAL_STREAM_TYPE_FLAT_TRIPLES</code> Continuous \u2718 \u2718 <code>LOGICAL_STREAM_TYPE_FLAT_QUADS</code> \u2718 Continuous Continuous <p>In the table above, the following interpretations are used:</p> <ul> <li>Framed \u2013 each stream frame SHOULD be interpreted as a stream element, as per RDF-STaX definition.</li> <li>Continuous \u2013 the stream SHOULD be interpreted as a continuous flat stream of elements, as per RDF-STaX definition. In this case, the stream frames carry no meaning.</li> <li>\u2718 \u2013 the combination of the logical stream type and the physical stream type is not directly supported.</li> </ul> <p>The implementations MAY choose to interpret the stream in a different manner than the one specified in the table.</p> <p>Note</p> <p>See the user's guide for a more intuitive explanation of what this means.</p> <p>In any case, you can choose to entirely ignore this table which should only be treated as a recommended starting point. For example, you could have an RDF graph stream with physical type <code>GRAPHS</code>, where each graph spans multiple stream frames. This and other non-standard combinations are completely fine, just make sure that all actors involved support it.</p>"},{"location":"specification/serialization/#stream-options","title":"Stream options","text":"<p>The stream options is a message of type <code>RdfStreamOptions</code> (reference). It MUST be the first row in the stream. It MAY appear more than once in the stream (also after other rows), but it MUST be identical to all previous occurrences. Consumer SHOULD throw an error if any subsequent stream options header differs from those seen previously in the stream. Implementations MAY throw an error if the stream options header is not present at the start of the stream. Alternatively, they MAY use their own, implementation-specified default options. Implementations SHOULD NOT throw an error if the stream options header is present more than once in the stream.</p> <p>The stream options header instructs the consumer of the stream (parser) on the size of the needed lookups to decode the stream and the features used by the stream.</p> <p>The stream options header contains the following fields:</p> <ul> <li><code>stream_name</code> (1) \u2013 name of the stream. This field is OPTIONAL and the manner in which it should be used is not defined by this specification. It MAY be used to identify the stream.</li> <li><code>physical_type</code> (2) \u2013 physical type of the stream. This field is REQUIRED.</li> <li><code>generalized_statements</code> (3) \u2013 whether the stream contains generalized RDF triples or graphs. This field MUST be set to true if the stream contains generalized RDF triples or graphs. It SHOULD NOT be set to true if the stream does not use this feature. This field is OPTIONAL and defaults to false.</li> <li><code>rdf_star</code> (4) \u2013 whether the stream uses RDF-star (quoted triples). This field MUST be set to true if the stream uses RDF-star. It SHOULD NOT be set to true if the stream does not use this feature. This field is OPTIONAL and defaults to false.</li> <li><code>max_name_table_size</code> (9) \u2013 maximum size of the name lookup. This field is REQUIRED and MUST be set to a value greater than or equal to 8. The size of the lookup MUST NOT exceed the value of this field.</li> <li><code>max_prefix_table_size</code> (10) \u2013 maximum size of the prefix lookup. This field is OPTIONAL and defaults to 0 (no lookup). If the field is set to 0, the prefix lookup MUST NOT be used in the stream. If the field is set to a positive value, the prefix lookup SHOULD be used in the stream and the size of the lookup MUST NOT exceed the value of this field.</li> <li><code>max_datatype_table_size</code> (11) \u2013 maximum size of the datatype lookup. This field is OPTIONAL and defaults to 0 (no lookup). If the field is set to 0, the datatype lookup MUST NOT be used in the stream (which effectively prohibits the use of datatype literals). If the field is set to a positive value, the datatype lookup SHOULD be used in the stream and the size of the lookup MUST NOT exceed the value of this field.</li> <li><code>logical_type</code> (14) \u2013 logical type of the stream, based on RDF-STaX. This field is OPTIONAL and defaults to <code>LOGICAL_STREAM_TYPE_UNSPECIFIED</code>.</li> <li><code>version</code> (15) \u2013 version tag of the stream. This field is REQUIRED.<ul> <li>The version tag is encoded as a varint. The version tag MUST be greater than 0.</li> <li>The producer of the stream MUST set the version tag to the version tag of the protocol that was used to serialize the stream.</li> <li>It is RECOMMENDED that the producer uses the lowest possible version tag that is compatible with the features used in the stream.</li> <li>The consumer SHOULD throw an error if the version tag is greater than the version tag of the implementation.</li> <li>The consumer SHOULD throw an error if the version tag is zero.</li> <li>The consumer SHOULD NOT throw an error if the version tag is not zero but lower than the version tag of the implementation.</li> <li>The producer may use version tags greater than 10000 to indicate non-standard versions of the protocol.</li> </ul> </li> </ul>"},{"location":"specification/serialization/#prefix-name-and-datatype-lookup-entries","title":"Prefix, name, and datatype lookup entries","text":"<p>Jelly uses a common mechanism of lookup tables for IRI prefixes, IRI names (postfixes), and datatypes. The lookups are used to compress the IRIs and datatypes in the stream. All lookups share the same base mechanism:</p> <ul> <li>The lookup is a map from a varint to a valid UTF-8 string.</li> <li>The lookup can be modified at any point in the stream. The modification consists of setting the lookup for a given varint to a given string. The modification MUST be applied to all subsequent rows in the stream.</li> <li>The first use of a given lookup element MUST be after it is defined in the lookup. If the consumer encounters a lookup element that is not defined in the lookup, it SHOULD throw an error.</li> <li>The lookups are indexed from <code>1</code>. The default value of <code>0</code> is a special value:<ul> <li>If the index is set to <code>0</code> in the first entry of the lookup in the stream, it MUST be interpreted as the value <code>1</code>.</li> <li>If the index is set to <code>0</code> in any other lookup entry, it MUST be interpreted as <code>previous_index + 1</code>, that is, the index of the previous entry incremented by one.</li> </ul> </li> <li>The maximum size of the lookup is communicated at the start of the stream (see stream options header). The producer of the stream MUST NOT exceed the maximum size of the lookup. The consumer of the stream MAY implement the lookup as a fixed-size array, or extend it dynamically.</li> <li>The lookup is updated with different messages, depending on the type of the lookup:<ul> <li><code>RdfNameEntry</code> for the name lookup,</li> <li><code>RdfPrefixEntry</code> for the prefix lookup,</li> <li><code>RdfDatatypeEntry</code> for the datatype lookup.</li> </ul> </li> <li>The producer may use any strategy to update the lookup.</li> </ul> <p>Note</p> <p>The spec does not specify what strategy should the producer use to update the lookup. You can use a the LRU strategy (as used in the Java implementation), LFU, or something more complex. You can also have a fixed lookup in the producer and communicate it at the start of the stream. This is possible if you are using a fixed set of prefixes, names, or datatypes and want to conserve computing power (e.g., in IoT devices).</p> <p>The simplest way to implement the consumer's lookup is to just use an indexed array of fixed size. The workload on the consumer's side is much lower than on the producer's side, so your choice of the strategy depends largely on the producer.</p> <p>Note</p> <p>The default value of <code>0</code> has a special meaning in lookup entries. You should take advantage of that and use it whenever possible. As the value of <code>0</code> is encoded with exactly zero bytes, you can save some space by using it.</p>"},{"location":"specification/serialization/#rdf-statements-and-graphs","title":"RDF statements and graphs","text":"<p>RDF statements (triples or quads) are communicated in three different ways, depending on the type of the stream:</p> <ul> <li><code>PHYSICAL_STREAM_TYPE_TRIPLES</code> \u2013 triples are encoded using <code>RdfTriple</code> messages.<ul> <li><code>RdfTriple</code> consists of three oneofs: <code>subject</code>, <code>predicate</code>, <code>object</code>, corresponding to the three terms in an RDF triple. Each of these oneofs has four fields, out of which at most one MUST be set.</li> <li>If no field in a given oneof is set, the term is considered to be a repeated term (see repeated terms).</li> </ul> </li> <li><code>PHYSICAL_STREAM_TYPE_QUADS</code> \u2013 quads are encoded using <code>RdfQuad</code> messages.<ul> <li><code>RdfQuad</code> consists of four oneofs: <code>subject</code>, <code>predicate</code>, <code>object</code>, <code>graph</code>, corresponding to the three terms and one graph node of the quad. Each of these oneofs has four fields, out of which at most one MUST be set.</li> <li>If no field in a given oneof is set, the term is considered to be a repeated term/graph node (see repeated terms).</li> </ul> </li> <li><code>PHYSICAL_STREAM_TYPE_GRAPHS</code> \u2013 graphs are encoded using <code>RdfGraphStart</code> and <code>RdfGraphEnd</code> messages. Triples between the start and end of the graph are encoded using <code>RdfTriple</code> messages. If a triple is between the start and end of the graph, it is considered to be in the graph.<ul> <li>In this type of stream, triples MUST NOT occur outside of a graph. If a triple is encountered outside a graph, the consumer SHOULD throw an error.</li> <li>A graph start MUST NOT occur inside another graph. If a graph start is encountered inside another graph, the consumer SHOULD throw an error.</li> <li>A graph end MUST NOT occur outside a graph. If a graph end is encountered outside a graph, the consumer MAY throw an error.</li> <li>A graph MAY be empty (i.e., it may contain no triples).</li> <li>A graph corresponding to one graph node MAY occur multiple times in a stream or a stream frame. The consumer MUST treat all occurrences of the graph as a single RDF graph.</li> <li>A graph MAY span more than one stream frame. The consumer MUST treat the graph spanning several stream frames as a single RDF graph.</li> <li>Exactly one field in the <code>RdfGraphStart</code> message MUST be set \u2013 no repeated terms are allowed here. The consumer MUST throw an error if no field in the <code>graph</code> oneof is set.</li> </ul> </li> </ul> <p>Note</p> <p>If the stream is meant to represent a single RDF dataset, then the graphs should be able to stretch across several stream frames. If the stream is meant to represent a stream of RDF datasets, then the graphs should be contained within a single stream frame.</p>"},{"location":"specification/serialization/#repeated-terms","title":"Repeated terms","text":"<p>Both <code>RdfTriple</code> and <code>RdfQuad</code> offer a simple compression mechanism \u2013 repeated terms. If a term in a given position (subject, predicate, object, or graph node in quads) is not set, then it is interpreted to be the same as the term in the same position in the previous triple or quad. Repeated terms are encoded simply by not setting any field in the corresponding oneof, and therefore take up zero bytes in the stream.</p> <ul> <li>Repeated terms MUST NOT occur in quoted triples.</li> <li>Repeated terms MUST NOT occur in the first statement row of the stream.</li> <li>Repeated terms MAY occur in the first statement row of a stream frame. In this case, the repeated terms MUST be interpreted as repeated from the previous stream frame.</li> <li>A repeated term in a given position MAY occur after a repeated term. The consumer MUST interpret all consecutive appearances of the repeated term as the same term.</li> </ul> Example (click to expand) <p>In the example the wrapping <code>RdfStreamRow</code>s were omitted for brevity:</p> <pre><code># First row\nRdfTriple {\n    s_iri: RdfIri {\n        prefix_id: 1\n        name_id: 1\n    }\n    p_iri: RdfIri {\n        prefix_id: 1\n        name_id: 2\n    }\n    o_bnode: \"b1\"\n}\n\n# Second row \u2013 repeating the subject and predicate\n# s_iri and p_iri are reused from the previous row\nRdfTriple {\n    o_bnode: \"b2\"\n}\n\n# Third row \u2013 repeating the subject and object\n# s_iri and o_bnode are reused from the first row\nRdfTriple {\n    p_iri: RdfIri {\n        prefix_id: 2\n        name_id: 3\n    }\n}\n</code></pre> <p>Note</p> <p>Repeated terms are a simple, yet incredibly effective compression mechanism and you should use them whenever possible. They are doubly effective: not only you save space by not repeating the terms, but also repeated terms are not encoded at all (zero bytes on the wire), which saves even more space.</p> <p>Note</p> <p>Repeated terms can be simply implemented with four variables (s, p, o, g) holding the last non-repeated value of a term in that position. This O(1) solution is what the Java implementation uses.</p> <p>Note</p> <p>Although repeated terms can stretch across stream frame boundaries (i.e., refer to values last seen in the previous stream frame), you don't have to use this feature. If your use case requires the stream frames to be more independent of each other (see: stream frame ordering), you can just reset the repeated terms at the start of each stream frame.</p>"},{"location":"specification/serialization/#rdf-terms-and-graph-nodes","title":"RDF terms and graph nodes","text":"<p>RDF terms and graph nodes are encoded using oneofs in <code>RdfTriple</code>, <code>RdfQuad</code>, and <code>RdfGraphStart</code>. The oneofs have each several fields, depending on the type of the term: <code>*_iri</code>, <code>*_bnode</code>, <code>*_literal</code>, <code>*_triple_term</code>, <code>g_default_graph</code>, corresponding to RDF IRIs, blank nodes, literals, RDF-star quoted triples, and the default RDF graph in an RDF dataset, respectively. At most one field in each oneof MUST be set.</p>"},{"location":"specification/serialization/#iris","title":"IRIs","text":"<p>The IRIs are encoded using the <code>RdfIri</code> message. The message has two fields that together make up the IRI:</p> <ul> <li><code>prefix_id</code> (1) \u2013 1-based index of the prefix of the IRI, corresponding to an entry in the prefix lookup.<ul> <li>The default value of <code>0</code> MUST be interpreted as the same value as in the last explictly specified (non-zero) prefix identifier.</li> <li>If <code>0</code> appears in the first IRI of the stream (and in any subsequent IRI), this MUST be interpreted as an empty prefix (zero-length string). This is for example used when the prefix lookup table is set to size zero.</li> </ul> </li> <li><code>name_id</code> (2) \u2013 1-based index of the name (suffix) of the IRI, corresponding to an entry in the name lookup.<ul> <li>The default value of <code>0</code> MUST be interpreted as <code>previous_name_id + 1</code>, that is, the <code>name_id</code> of the previous IRI incremented by one.</li> <li>If <code>0</code> appears in the first IRI of the stream it MUST be interpreted as <code>1</code>.</li> <li>Multiple <code>0</code> values in a row may occur, in which case the <code>name_id</code> MUST be interpreted as incrementing by one for each <code>0</code> value.</li> </ul> </li> </ul> <p>For the default value behavior to work correctly, IRIs in the stream MUST be processed strictly in order: firstly by stream row, then by term (subject, predicate, object, graph). This also applies recursively to RDF-star quoted triples and to namespace declarations.</p> <p>The IRI is then constructed by first decoding the prefix and the name using the prefix and name lookup tables, and then concatenating the prefix and the name. The IRI SHOULD be a valid IRI, as defined in RFC 3987.</p> Example with the prefix table (click to expand) <p>Assume the following lookup entries were defined in the stream (wrapping <code>RdfStreamRow</code>s were omitted for brevity):</p> <pre><code>RdfPrefixEntry {\n    id: 0 # default value, interpreted as 1\n    prefix: \"http://example.com/\"\n}\nRdfNameEntry {\n    id: 0 # default value, interpreted as 1\n    name: \"example\"\n}\nRdfNameEntry {\n    id: 0 # default value, interpreted as 1 + 1 = 2\n    name: \"\"\n}\nRdfNameEntry {\n    id: 0 # default value, interpreted as 2 + 1 = 3\n    name: \"test\"\n}\n</code></pre> <p>Then the following IRIs are encoded as follows:</p> <pre><code># http://example.com/example\nRdfIri {\n    prefix_id: 1\n    name_id: 0 # default value, interpreted as 1\n} \n\n# http://example.com/\nRdfIri {\n    prefix_id: 0 # default value, interpreted as 1\n    name_id: 0 # default value, interpreted as 1 + 1 = 2\n}\n\n# http://test.com/test\nRdfIri {\n    prefix_id: 0 # default value, interpreted as 1\n    name_id: 0 # default value, interpreted as 2 + 1 = 3\n}\n</code></pre> <p>Note that the default values (zeroes) are not encoded at all in Protobuf and therefore take up zero bytes in the stream.</p> Example without the prefix table (click to expand) <p>In this example, the prefix lookup table is not used. The lookup entries are defined as follows:</p> <pre><code>RdfNameEntry {\n    id: 0 # default value, interpreted as 1\n    name: \"http://example.com/example\"\n}\n\nRdfNameEntry {\n    id: 0 # default value, interpreted as 1 + 1 = 2\n    name: \"http://example.com/test\"\n}\n</code></pre> <p>Then the following IRIs are encoded as follows:</p> <pre><code># http://example.com/example\nRdfIri {\n    prefix_id: 0 # default value, interpreted as empty prefix\n    name_id: 0 # default value, interpreted as 1\n}\n\n# http://example.com/test\nRdfIri {\n    prefix_id: 0 # default value, interpreted as empty prefix\n    name_id: 0 # default value, interpreted as 1 + 1 = 2\n}\n</code></pre> <p>Note</p> <p>The spec does not specify how to split the IRIs into names and prefixes. You can use any strategy you want, as long as you follow the rules above. The simplest way is to split the IRI at the last occurrence of the <code>#</code> or <code>/</code> character \u2013 this is what the Java implementation uses. </p> <p>These prefixes are not meant to be user-facing, they can be entirely arbitrary and DO NOT correspond to, for example <code>@prefix</code> declarations in Turtle. If you want to preserve such user-facing namespace declarations, use the <code>RdfNamespaceDeclaration</code> feature instead.</p> <p>Note</p> <p>The behavior of the default values is designed to save space in the stream. Usually in RDF many IRIs share the same prefix, so you can save space by not repeating the prefix in the stream. At the same time the name part of the IRI is often unique, so for each name you will need a new entry in the lookup table \u2013 which is often the next entry after the one you have just created.</p>"},{"location":"specification/serialization/#blank-nodes","title":"Blank nodes","text":"<p>RDF blank nodes are represented using simple strings. The string is the identifier of the blank node. The identifier MUST be a valid UTF-8 string.</p> <p>Because the spec does not define the semantics of the stream frames, blank node identifiers are not guaranteed to be unique across multiple stream frames. The consumer MAY choose to treat the blank nodes as unique across the stream (and thus treat all occurences of the identifier as a single node), or it MAY choose to treat them as unique only within a single stream frame. The consumer MAY use the logical stream type to determine how to treat the blank nodes. The producer SHOULD specify in the documentation which strategy it uses.</p> <p>Note</p> <p>If the stream is meant to represent a single RDF graph or dataset (flat RDF stream in RDF-STaX), then the blank node identifiers should be unique across the stream so that you can refer to them across stream frame boundaries. If the frames refer to different graphs or datasets (grouped RDF stream in RDF-STaX), then the blank node identifiers should be unique only within a single frame.</p> <p>Note</p> <p>Many RDF libraries (e.g., RDF4J, Apache Jena) use internal identifiers for blank nodes, which can be used as the identifiers in Jelly streams. You can also use a different format, for example with shorter identifiers to preserve space.</p>"},{"location":"specification/serialization/#literals","title":"Literals","text":"<p>RDF literals are represented using the <code>RdfLiteral</code> message (reference). The message has the following fields:</p> <ul> <li><code>lex</code> (1) \u2013 the lexical form of the literal in UTF-8. This field is OPTIONAL and defaults to an empty string.</li> <li><code>literalKind</code> oneof. At most one of the following fields MUST be set:<ul> <li><code>langtag</code> (2) \u2013 UTF-8 language tag, indicating that the literal is a language-tagged string (has datatype IRI equal to <code>http://www.w3.org/1999/02/22-rdf-syntax-ns#langString</code>). The language tag SHOULD be a valid BCP 47 language tag.</li> <li><code>datatype</code> (3) \u2013 1-based index of the datatype in the datatype lookup, indicating that the literal is a typed literal. The value of this field MUST be greater than 0 and it MUST correspond to a valid entry in the datatype lookup.</li> </ul> </li> </ul> <p>If no field in the <code>literalKind</code> oneof is set, then the literal MUST be interpreted as a simple literal (has datatype IRI equal to <code>http://www.w3.org/2001/XMLSchema#string</code>).</p> <p>Note</p> <p>Using the default value of <code>0</code> for the <code>datatype</code> field is not allowed, in contrast to names and prefixes in RdfIri. This is because the <code>datatype</code> field itself is optional and the default value would be ambiguous.</p>"},{"location":"specification/serialization/#quoted-triples-rdf-star","title":"Quoted triples (RDF-star)","text":"<p>RDF-star quoted triples are represented using the <code>RdfTriple</code> message (reference). Quoted triples are encoded in the same manner as triple statements, with the only difference being that repeated terms MUST NOT be used in quoted triples. The consumer MUST throw an error if a repeated term is encountered in a quoted triple.</p> <p>Quoted triples may be nested up to arbitrary depth. The consumer SHOULD throw an error if the depth of the nesting exceeds the capabilities of the implementation.</p>"},{"location":"specification/serialization/#graph-nodes","title":"Graph nodes","text":"<p>Literal, IRI, and blank node values for graph nodes are encoded in the same manner as for the subject, predicate, and object terms.</p> <p>The default graph node is represented using the <code>RdfDefaultGraph</code> message (reference). The message is empty and has no fields. The default graph node indicates that the triple is part of the default graph.</p>"},{"location":"specification/serialization/#namespace-declarations","title":"Namespace declarations","text":"<p>IRI namespace declarations are not a part of the RDF Abstract Syntax. They are a convenience / cosmetic feature of the serialization format to allow preserving associations between short namespace names and full IRIs. Namespace declarations are encoded using the <code>RdfNamespaceDeclaration</code> message (reference). The message has the following fields:</p> <ul> <li><code>name</code> (1) \u2013 the short name of the namespace, encoded in UTF-8. It SHOULD conform to the <code>PN_PREFIX</code> production in RDF 1.1 Turtle. Note that the <code>:</code> character (colon) is not part of the name. An empty string (the default value) is allowed.</li> <li><code>value</code> (2) \u2013 the IRI of the namespace as an <code>RdfIri</code> message. This field is REQUIRED.</li> </ul> <p>Namespace declarations have no effect on the interpretation of the stream in terms of the RDF Abstract Syntax. Therefore, they MUST NOT be used to, for example, shorten IRIs in the stream. The namespace declarations are purely cosmetic and are meant to be used only to preserve human-readable prefixes between the producer and the consumer.</p> <p>Note</p> <p>To clarify: <code>RdfIri</code> messages in namespace declarations are treated EXACTLY in the same way as terms in triples or quads. That means that the default value of <code>0</code> has the exact same meaning. You can freely intersperse namespace declarations with triples or quads. For example, if you first have a namespace declaration with <code>prefix_id</code> set to <code>5</code>, then the next <code>RdfIri</code> message in a triple with <code>prefix_id</code> set to <code>0</code> will be interpreted as the same prefix (<code>5</code>) as in the namespace declaration.</p> Example (click to expand) <p>To encode the Turtle namespace declaration <code>@prefix ex: &lt;http://example.com/&gt; .</code> you would use the following messages (the wrapping <code>RdfStreamRow</code>s were omitted for brevity):</p> <pre><code>RdfPrefixEntry {\n    id: 0 # default value, interpreted as 1\n    value: \"http://example.com/\"\n}\n\n# We must define an empty name entry, because the name part is always required\nRdfNameEntry {\n    id: 0 # default value, interpreted as 1\n    value: \"\"\n}\n\nRdfNamespaceDeclaration {\n    name: \"ex\"\n    value: RdfIri {\n        prefix_id: 1\n        name_id: 0 # default value, interpreted as 1\n    }\n}\n</code></pre> <p>Alternatively, if not using the prefix lookup table:</p> <pre><code>RdfNameEntry {\n    id: 0 # default value, interpreted as 1\n    value: \"http://example.com/\"\n}\n\nRdfNamespaceDeclaration {\n    name: \"ex\"\n    value: RdfIri {\n        prefix_id: 0 # default value, interpreted as empty prefix\n        name_id: 0 # default value, interpreted as 1\n    }\n}\n</code></pre>"},{"location":"specification/serialization/#delimited-variant-of-jelly","title":"Delimited variant of Jelly","text":"<p>Note</p> <p>By default, Protobuf messages are not delimited, so if you write multiple messages to the same file / socket / byte stream, you need to add some kind of delimiter between them. Jelly uses the convention already implemented in some protobuf libraries of prepending a varint before the message, to specify the length of the message. </p> <p>A byte stream (or file) in the delimited variant MUST consist of a series of delimited <code>RdfStreamFrame</code> messages. A delimited message is a message that has a Protobuf varint prepended before it, specifying the length of the message in bytes.</p>"},{"location":"specification/serialization/#delimited-variant-implementations","title":"Delimited variant implementations","text":"<p>The delimiting convention is implemented in Protobuf libraries for:</p> <ul> <li>C++: delimited_message_util.cc</li> <li>Java: writeDelimitedTo and parseDelimitedFrom</li> <li>Python: serialize_length_prefixed and parse_length_prefixed</li> </ul> <p>The JVM implementation of Jelly also supports the delimited variant \u2013 see the documentation.</p>"},{"location":"specification/serialization/#internet-media-type-and-file-extension","title":"Internet media type and file extension","text":"<p>The RECOMMENDED media type for Jelly is <code>application/x-jelly-rdf</code>. The RECOMMENDED file extension is <code>.jelly</code>.</p> <p>The files SHOULD be saved in the delimited variant of Jelly.</p>"},{"location":"specification/serialization/#security-considerations","title":"Security considerations","text":"<p>This section is not part of the specification.</p>"},{"location":"specification/serialization/#protocol-buffers","title":"Protocol Buffers","text":"<p>The Jelly serialization format is based on Protocol Buffers, which handles all binary manipulation, and therefore is most likely to be the main security concern. Please refer to the Protobuf Version Support page for information on security patches and support. See also the published CVE Records for Protocol Buffers.</p>"},{"location":"specification/serialization/#overly-large-lookup-tables","title":"Overly large lookup tables","text":"<p>For untrusted input, consumers must always validate that the requested size of a prefix, name, or datatype lookup table is not overly large and supported by the consumer. A malicious producer could attempt to exhaust the memory of the consumer by requesting a lookup table of several gigabytes or more. This would constitute a denial-of-service vector.</p> <p>The recommended mitigation is for each implementation to define a maximum allowed lookup size and check if the requested size is within the limit. If the requested size exceeds the limit, the consumer should throw an error and reject the stream.</p> <p>Info</p> <p>The Jelly-JVM implementation uses a configurable limit (up to 4096 entries by default). The mechanism is described here.</p> <p>The Jelly gRPC streaming protocol has a built-in mechanism for stream options handling that does include such checks. See the gRPC streaming protocol specification.</p>"},{"location":"specification/serialization/#invalid-lookup-entry-ids-and-references","title":"Invalid lookup entry IDs and references","text":"<p>For untrusted input, consumers must always validate that the lookup entry IDs in the stream are valid and within the bounds of the lookup table. A malicious producer could attempt to reference a non-existent entry in the lookup table, which could lead to it reading or writing arbitrary memory.</p> <p>This is automatically handled by languages that include array bounds checking, such as Java or Python. In languages without array bounds checking, the consumer must manually check that the lookup entry ID is within the bounds of the lookup table.</p>"},{"location":"specification/serialization/#infinite-recursion-of-rdf-star-quoted-triples","title":"Infinite recursion of RDF-star quoted triples","text":"<p>A malicious producer may attempt to create a stream with RDF-star quoted triples that are nested to an arbitrary depth. This could lead to a stack overflow in the consumer, which could be used as a denial-of-service vector.</p> <p>The official Protobuf implementations are not vulnerable to this type of attack, as they include a message recursion limit (100 by default). Implementations should verify that their Protobuf library supports this limit and that it is set to a reasonable value.</p> <p>Info</p> <p>In practice, there are very few (if any) use cases where very deep recursive nesting would be needed for Jelly. Unless you are working with some very exotic data, you should be fine with setting the recursion limit to as low as 10 messages. But still, even the default limit of 100 should not cause you any problems, unless operating under extremely constrained environments.</p> <p>Streams without RDF-star require only 4 nesting levels. Each nested RDF-star quoted triple adds one level of nesting.</p>"},{"location":"specification/serialization/#rdf-content","title":"RDF content","text":"<p>Jelly is a general serialization format for RDF data, and as such, may be used to transmit malicious or misleading content, such as links to phishing websites or false information. Please refer to the RDF 1.1 Turtle W3C Recommendation for information on security considerations related to RDF content.</p>"},{"location":"specification/serialization/#encryption-authentication-and-authorization","title":"Encryption, authentication, and authorization","text":"<p>Jelly does not provide any built-in mechanisms for encryption, authentication, or authorization, as it only handles data serialization. If you need to secure your data, you should use a secure transport layer (e.g., HTTPS) and implement encryption, authentication, and authorization on the application level.</p>"},{"location":"specification/serialization/#implementations","title":"Implementations","text":"<p>This section is not part of the specification.</p> <p>The following implementations of the Jelly RDF serialization format specification are available:</p> <ul> <li>Jelly-JVM implementation<ul> <li>Specification version: dev</li> <li>Implemented actors: producer, consumer</li> <li>Supported RDF libraries: Apache Jena, RDF4J, Titanium RDF API</li> </ul> </li> <li>pyjelly implementation<ul> <li>Specification version: dev</li> <li>Implemented actors: producer, consumer</li> <li>Supported RDF libraries: rdflib</li> </ul> </li> </ul>"},{"location":"specification/streaming/","title":"Jelly gRPC streaming protocol specification","text":"<p>This document is the specification of the Jelly gRPC streaming protocol (publish/subscribe mechanism). It is intended for implementers of Jelly libraries and applications. If you are looking for a user-friendly introduction to Jelly, see the Jelly index page.</p> <p>This document is accompanied by the Jelly Protobuf reference and the Protobuf definition itself (<code>grpc.proto</code>).</p> <p>The following assumptions are used in this document:</p> <ul> <li>This document uses the specification for the Jelly serialization format.</li> <li>All strings in the mentioned Protobuf messages are assumed to be UTF-8 encoded.</li> <li>Standard gRPC status codes are used, as defined in gRPC documentation.</li> </ul> Document information Author: Piotr Sowi\u0144ski (Ostrzyciel) Version: dev Date: June 3, 2025 Permanent URL: <code>https://w3id.org/jelly/dev/specification/streaming</code> Document status: Draft specification <p>Info</p> <p>The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.</p> <p>Note</p> <p>The \"Note\" blocks in this document are not part of the specification, but rather provide additional information for implementers.</p>"},{"location":"specification/streaming/#conformance","title":"Conformance","text":"<p>Implementations MAY choose to implement only a subset of the following specification. In this case, they SHOULD clearly specify which parts of the specification they implement. In the rest of this specification, the keywords \"MUST\", \"MUST NOT\", etc. refer to full (not partial) implementations.</p>"},{"location":"specification/streaming/#versioning","title":"Versioning","text":"<p>The streaming protocol follows the Semantic Versioning 2.0 scheme. The version of the gRPC streaming protocol is equal to the version of the corresponding serialization format (1:1 equivalence). The version of the protocol is specified in the stream options \u2013 see the serialization specification for details.</p> <p>Note</p> <p>Releases of the protocol are published on GitHub.</p>"},{"location":"specification/streaming/#backward-compatibility","title":"Backward compatibility","text":"<p>Implementations SHOULD ensure backward compatibility. To achieve backward compatibility, the implementation MUST be able to respond to all RPCs from the previous releases of the protocol with the same MAJOR version. The implementation MAY also be able to respond to RPCs from previous releases of the protocol with a different MAJOR version.</p> <p>Note</p> <p>The protocol is designed in such a way that you don't need to worry about backward compatibility. The only thing you need to do is to implement the latest version of the protocol, and you will automatically get backward compatibility with all previous versions (of the same MAJOR).</p>"},{"location":"specification/streaming/#forward-compatibility","title":"Forward compatibility","text":"<p>Forward compatibility is not guaranteed. Implementations MAY be able to respond to RPCs from future releases of the protocol with the same MAJOR version. Implementations MAY also be able to respond to RPCs from future releases of the protocol with a different MAJOR version.</p>"},{"location":"specification/streaming/#actors-and-implementations","title":"Actors and implementations","text":"<p>The Jelly gRPC streaming protocol assumes there to be two actors: the server and the client. These actors can both play the role of the producer or the consumer of the stream (see serialization specification), depending on the direction of the stream.</p> <p>Implementations may include only the server, only the client, or both.</p>"},{"location":"specification/streaming/#protocol-specification","title":"Protocol specification","text":"<p>The protocol specifies a simple publish/subscribe mechanism topics identified with UTF-8 strings. The client can subscribe to a topic and receive messages published to that topic by the server. The client can also publish messages to a topic.</p> <p>The described protocol is implemented as a gRPC service <code>RdfStreamService</code> (reference).</p> <p>Note</p> <p>The protocol does not specify what happens to the messages on the server \u2013 this is NOT a broker or message queue specification. The protocol is meant to enable point-to-point communication, but can also be used to implement a broker or a similar service (see Usage notes below).</p> <p>You can also ignore the topics and use the protocol as a simple streaming protocol.</p>"},{"location":"specification/streaming/#topics","title":"Topics","text":"<p>Topics are identified with UTF-8 strings. The topic string MUST be valid UTF-8. There are no further restrictions on the topic string.</p> <p>Note</p> <p>The topic can be whatever you like \u2013 it can also be empty. It is up the user to decide what to use the topics for, or if to use them at all.</p>"},{"location":"specification/streaming/#subscribing-to-a-stream","title":"Subscribing to a stream","text":"<p>The client subscribes to a stream from the server with the <code>SubscribeRdf</code> RPC (reference). The RPC is initiated with an <code>RdfStreamSubscribe</code> message (reference) from the client. The message includes two OPTIONAL fields:</p> <ul> <li><code>topic</code> (1) \u2013 the topic to subscribe to. The default is an empty string.</li> <li><code>options</code> (2) \u2013 the stream options (<code>RdfStreamOptions</code>). The default is an empty message.</li> </ul> <p>The server MUST respond with either a stream of <code>RdfStreamFrame</code> messages or an error.</p>"},{"location":"specification/streaming/#stream-options-handling","title":"Stream options handling","text":"<p>The client MAY request specific options for the stream it subscribes to. In that case, the client MUST include the <code>options</code> field in the <code>RdfStreamSubscribe</code> message. The server SHOULD respond with a stream that uses options that are compatible with the options requested by the client. If the server cannot respond with a stream that uses options that are compatible with the options requested by the client, the server MUST respond with the <code>INVALID_ARGUMENT</code> error.</p> <p>The following rules are used to determine if the options are compatible. All rules MUST be satisfied for the options to be compatible.</p> Option Client request Server response <code>stream_name</code> <code>x</code> MAY be <code>x</code> <code>physical_type</code> <code>x</code> MUST be <code>x</code> <code>generalized_statements</code> <code>x</code> MUST be <code>x</code> or false <code>use_repeat</code> <code>x</code> MUST be <code>x</code> or false <code>rdf_star</code> <code>x</code> MUST be <code>x</code> or false <code>max_name_table_size</code> <code>x</code> MUST be &lt;= <code>x</code> <code>max_prefix_table_size</code> <code>x</code> MUST be &lt;= <code>x</code> <code>max_datatype_table_size</code> <code>x</code> MUST be &lt;= <code>x</code> <code>logical_type</code> <code>x</code> MAY be <code>x</code> <code>version</code> <code>x</code> MUST be &lt;= <code>x</code> <p>Note</p> <p>The server should implement some limits for the stream options it supports, for example the maximum size of the name table. Otherwise, a client may request a name table that takes up all the server's memory.</p> <p>Logical stream type handling is entirely dependent on the server implementation:</p> <ol> <li>The server MAY respect the client's request in the <code>logical_type</code> field in the stream options and respond with the same type.</li> <li>The server MAY respect the client's request in the <code>logical_type</code> field in the stream options and respond with a subtype of the requested type.</li> <li>The server MAY ignore the <code>logical_type</code> field in the client request and respond with its own type or with no type at all.</li> <li>The server MAY respond with an <code>INVALID_ARGUMENT</code> error if the client requests a type that the server does not support with the specified physical stream type.</li> </ol> <p>Note</p> <p>How you implement this behavior depends on your use case, possibly combining the above options. For example, you may want to allow the client to request a specific logical type, but only if it is compatible with the physical type. Or, if your server supports stream type conversion, you may want to allow the client to request a specific logical type and let the server handle the conversion.</p>"},{"location":"specification/streaming/#publishing-a-stream","title":"Publishing a stream","text":"<p>The client publishes a stream to the server with the <code>PublishRdf</code> RPC (reference). The RPC is initiated with a stream of <code>RdfStreamFrame</code> messages from the client. The stream MUST include at least one message. The first frame MUST include a row with the stream options as the first row. After the stream successfully completes, the server MUST respond with the <code>RdfStreamReceived</code> message (reference).</p> <p>If the server cannot handle the stream with the specified options, the server MUST respond with the <code>INVALID_ARGUMENT</code> error.</p>"},{"location":"specification/streaming/#usage-notes","title":"Usage notes","text":"<p>This section is not part of the specification.</p> <p>The protocol is deliberately very general and unrestrictive. The pub/sub mechanism can be used in a number of ways, possibly extending the existing base protocol. The following are some examples of how the protocol can be used:</p> <ul> <li>Server publishing a number of streams, each with a different topic.</li> <li>RDF stream broker or message queue \u2013 the server acts as a \"hub\" aggregating RDF data sent to a topic by clients, and then forwarding it to other clients.</li> <li>Microservice chains \u2013 one service can process an RDF stream, forward it to another service, etc.</li> </ul> <p>These use cases can be implemented with the protocol as-is, or by extending the protocol with additional messages and/or RPCs. In either case, the protocol provides a base layer for compatibility between different implementations.</p>"},{"location":"specification/streaming/#stream-frame-size","title":"Stream frame size","text":"<p>This section is not part of the specification.</p> <p>The size of the stream frame is not limited by the protocol, nor by gRPC itself. However, many gRPC implementations have a limit on the size of the message at around 4 MB. It is recommended to use much smaller messages (e.g., 100 KB), which will also make it easier to serialize and deserialize the messages. For most use cases of RDF graph/dataset streams (like IoT messaging), this should be sufficient. Otherwise, you will have to split the frames into smaller messages.</p>"},{"location":"specification/streaming/#long-running-streams-and-keep-alive-pings","title":"Long-running streams and keep-alive pings","text":"<p>This section is not part of the specification.</p> <p>The gRPC protocol does support long-running streams, but due to how it's implemented (over HTTP/2 and TCP), some networking equipment or network stack implementations may terminate a connection if there is no activity for a long time. If you are working with a stream that can be \"quiet\" for more than a minute, this may be a problem.</p> <p>To prevent this, HTTP/2 ping frames can be used by the server to periodically ping the client, keeping the connection alive. This is implemented in many HTTP/2 libraries. For example in Apache Pekko HTTP, one needs to set the <code>pekko.http.server.http2.ping-interval</code> configuration option to a non-zero value. This is done in Jelly-JVM's gRPC module by default.</p>"},{"location":"specification/streaming/#security-considerations","title":"Security considerations","text":"<p>This section is not part of the specification.</p>"},{"location":"specification/streaming/#grpc","title":"gRPC","text":"<p>The Jelly gRPC streaming protocol is built on top of gRPC. Please refer to the documentation of your gRPC implementation for security considerations. See also the notes on gRPC authentication.</p>"},{"location":"specification/streaming/#jelly-serialization-format","title":"Jelly serialization format","text":"<p>All security considerations from the Jelly serialization format specification apply. Most relevant here is validating the stream options to prevent denial-of-service attacks. This is covered in this specification in section \"Stream options handling\".</p>"},{"location":"specification/streaming/#implementations","title":"Implementations","text":"<p>This section is not part of the specification.</p> <p>The following implementations of the Jelly gRPC streaming protocol specification are available:</p> <ul> <li>Jelly-JVM implementation<ul> <li>Specification version: dev</li> <li>Partial (boilerplate) implementation based on Apache Pekko gRPC. Requires the end user to implement their own code for handling the streams.</li> </ul> </li> </ul>"},{"location":"specification/includes/back_compat/","title":"Back compat","text":"<p>Implementations SHOULD ensure backward compatibility. To achieve backward compatibility, the implementation MUST be able to read all messages from the previous releases of the protocol with the same MAJOR version. The implementation MAY also be able to read messages from previous releases of the protocol with a different MAJOR version.</p> <p>Note</p> <p>The protocol is designed in such a way that you don't need to worry about backward compatibility. The only thing you need to do is to implement the latest version of the protocol, and you will automatically get backward compatibility with all previous versions (of the same MAJOR).</p>"},{"location":"specification/includes/conformance/","title":"Conformance","text":"<p>Implementations MAY choose to implement only a subset of the following specification. In this case, they SHOULD clearly specify which parts of the specification they implement. In the rest of this specification, the keywords \"MUST\", \"MUST NOT\", etc. refer to full (not partial) implementations.</p> <p>Note</p> <p>Implementations may in particular choose to not implement features that are not supported on the target platform (e.g., RDF datasets, RDF-star, generalized RDF terms, etc.).</p> <p>Implementations MAY also choose to extend Jelly with additional features that SHOULD NOT interfere with the serialization being readable by implementations which follow the specification.</p>"},{"location":"specification/includes/forward_compat/","title":"Forward compat","text":"<p>Forward compatibility is not guaranteed across different MINOR versions of the protocol. Implementations MAY be able to read messages from future releases of the protocol with the same MAJOR version. Implementations MAY also be able to read messages from future releases of the protocol with a different MAJOR version.</p> <p>New features introduced in PATCH versions of the protocol MUST NOT break forward compatibility.</p>"},{"location":"specification/includes/start_info/","title":"Start info","text":"<p>Info</p> <p>The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.</p> <p>Note</p> <p>The \"Note\" blocks in this document are not part of the specification, but rather provide additional information for implementers.</p> <p>Note</p> <p>The \"Example\" blocks in this document are not part of the specification, but rather provide informal examples of the serialization format.</p>"}]}