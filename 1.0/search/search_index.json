{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Test \u2013 index.md</p>"},{"location":"contributing/","title":"Contributing","text":"<p>TODO</p>"},{"location":"licensing/","title":"Licensing and citation","text":"<p>TODO</p>"},{"location":"jvm/","title":"Jelly JVM (Scala) implementation","text":""},{"location":"jvm/grpc/","title":"User guide \u2013 gRPC","text":""},{"location":"jvm/grpc/#example-grpc-pubsub","title":"Example \u2013 gRPC pub/sub","text":""},{"location":"jvm/implementation/","title":"Developer guide \u2013 implementing conversions for other libraries","text":"<p>Currently converters for the two most popular RDF JVM libraries are implemented \u2013 RDF4J and Jena. But it is possible to implement your own converters and adapt the Jelly serialization code to any RDF library with little effort.</p> <p>To do this, you will need to implement three traits (interfaces in Java) from the <code>jelly-core</code> module: <code>ProtoEncoder</code>, <code>ProtoDecoderConverter</code>, and <code>ConverterFactory</code>.</p> <ul> <li>ProtoEncoder (serialization)</li> <li><code>get*</code> methods deconstruct triple statements, quad statements, and quoted triples (RDF-star). You can make them <code>inline</code>.</li> <li><code>nodeToProto</code> and <code>graphToProto</code> should translate into Jelly's representation all possible variations of RDF terms in the SPO and G positions, respectively.</li> <li>Example implementation for Jena: JenaProtoEncoder</li> <li>You can skip implementing this trait if you don't need serialization.</li> <li> <p>You can also skip implementing some methods (make them throw an exception or return null) if, for example, you don't want to work with quads or RDF-start.</p> </li> <li> <p>ProtoDecoderConverter (deserialization)</p> </li> <li>The <code>make*</code> methods should construct new RDF terms and statements. You can make them <code>inline</code>.</li> <li>Example implementation for Jena: JenaDecoderConverter</li> <li>You can skip implementing this trait if you don't need deserialization.</li> <li> <p>You can also skip implementing some methods (make them throw an exception or return null) if, for example, you don't want to work with quads or RDF-start.</p> </li> <li> <p>ConverterFactory \u2013 wrapper that allows other modules to use your converter.</p> </li> <li>The methods should just return new instances of your <code>ProtoEncoder</code> and <code>ProtoDecoderConverter</code> implementations.</li> <li>Example for Jena: JenaConverterFactory</li> </ul>"},{"location":"jvm/reactive/","title":"User guide \u2013 reactive streaming","text":"<p>TODO</p>"},{"location":"jvm/reactive/#example-streaming-with-kafka","title":"Example: streaming with Kafka","text":""},{"location":"jvm/reactive/#byte-streams","title":"Byte streams","text":"<p>TODO</p> <p>(referenced by specification/serialization.md)</p>"},{"location":"jvm/releases/","title":"Developer guide \u2013 releases","text":""},{"location":"jvm/releases/#full-versioned-releases","title":"Full (versioned) releases","text":"<p>Full (versioned) releases are created manually and follow the Semantic Versioning scheme for binary compatibility.</p> <p>To create a new tagged release (example for version 1.2.3): <pre><code>$ git checkout main\n$ git pull\n$ git tag v1.2.3\n$ git push origin v1.2.3\n</code></pre></p> <p>The rest (packaging and release creation) will be handled automatically by the CI. The release will be pushed to Maven Central.</p>"},{"location":"jvm/releases/#snapshot-releases","title":"Snapshot releases","text":"<p>Snapshot releases are triggered automatically by commits in the <code>main</code> branch. Snapshots are pushed to the Sonatype snapshot repository.</p>"},{"location":"specification/","title":"Protocol specification","text":"<p>TODO</p>"},{"location":"specification/#stream-types","title":"Stream types","text":"<p>TODO</p>"},{"location":"specification/media-type/","title":"File extension and media type","text":"<p>Jelly is not tied to any specific file extension and does not have a registered media type. However, you can use the following:</p> <ul> <li>File extension: <code>.jelly</code></li> <li>Media type: <code>application/x-jelly-rdf</code></li> </ul> <p>The files should be saved in the delimited variant of Jelly.</p>"},{"location":"specification/media-type/#see-also","title":"See also","text":"<ul> <li>Serialization format specification</li> </ul>"},{"location":"specification/reference/","title":"Protocol Documentation","text":""},{"location":"specification/reference/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>grpc.proto</p> <ul> <li>RdfStreamReceived</li> <li> <p>RdfStreamSubscribe</p> </li> <li> <p>RdfStreamService</p> </li> </ul> </li> <li> <p>rdf.proto</p> <ul> <li>RdfDatatypeEntry</li> <li>RdfDefaultGraph</li> <li>RdfGraph</li> <li>RdfGraphEnd</li> <li>RdfGraphStart</li> <li>RdfIri</li> <li>RdfLiteral</li> <li>RdfLiteralSimple</li> <li>RdfNameEntry</li> <li>RdfPrefixEntry</li> <li>RdfQuad</li> <li>RdfRepeat</li> <li>RdfStreamFrame</li> <li>RdfStreamOptions</li> <li>RdfStreamRow</li> <li>RdfTerm</li> <li> <p>RdfTriple</p> </li> <li> <p>RdfStreamType</p> </li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"specification/reference/#grpcproto","title":"grpc.proto","text":""},{"location":"specification/reference/#rdfstreamreceived","title":"RdfStreamReceived","text":""},{"location":"specification/reference/#rdfstreamsubscribe","title":"RdfStreamSubscribe","text":"<p>=== Pub/Sub ===</p> Field Type Label Description topic string The topic to which the client wants to subscribe. requested_options RdfStreamOptions Optional: the stream options requested by the client. The server should respond with a stream that matches these options. In case that is not possible, the server must respond with the INVALID_ARGUMENT error. <p></p>"},{"location":"specification/reference/#rdfstreamservice","title":"RdfStreamService","text":"Method Name Request Type Response Type Description SubscribeRdf RdfStreamSubscribe RdfStreamFrame stream PublishRdf RdfStreamFrame stream RdfStreamReceived <p>Top</p>"},{"location":"specification/reference/#rdfproto","title":"rdf.proto","text":""},{"location":"specification/reference/#rdfdatatypeentry","title":"RdfDatatypeEntry","text":"Field Type Label Description id uint32 1-based value string"},{"location":"specification/reference/#rdfdefaultgraph","title":"RdfDefaultGraph","text":""},{"location":"specification/reference/#rdfgraph","title":"RdfGraph","text":"Field Type Label Description iri RdfIri bnode string literal RdfLiteral default_graph RdfDefaultGraph repeat RdfRepeat Only valid in a QUADS stream."},{"location":"specification/reference/#rdfgraphend","title":"RdfGraphEnd","text":""},{"location":"specification/reference/#rdfgraphstart","title":"RdfGraphStart","text":"Field Type Label Description graph RdfGraph"},{"location":"specification/reference/#rdfiri","title":"RdfIri","text":"<p>=== Rdf Terms ===</p> Field Type Label Description prefix_id uint32 Either of these can be zero if the prefix or the suffix are not used. name_id uint32 <p></p>"},{"location":"specification/reference/#rdfliteral","title":"RdfLiteral","text":"Field Type Label Description lex string simple RdfLiteralSimple langtag string datatype uint32"},{"location":"specification/reference/#rdfliteralsimple","title":"RdfLiteralSimple","text":""},{"location":"specification/reference/#rdfnameentry","title":"RdfNameEntry","text":"Field Type Label Description id uint32 1-based value string"},{"location":"specification/reference/#rdfprefixentry","title":"RdfPrefixEntry","text":"Field Type Label Description id uint32 1-based value string"},{"location":"specification/reference/#rdfquad","title":"RdfQuad","text":"Field Type Label Description s RdfTerm p RdfTerm o RdfTerm g RdfGraph"},{"location":"specification/reference/#rdfrepeat","title":"RdfRepeat","text":""},{"location":"specification/reference/#rdfstreamframe","title":"RdfStreamFrame","text":"Field Type Label Description rows RdfStreamRow repeated"},{"location":"specification/reference/#rdfstreamoptions","title":"RdfStreamOptions","text":"Field Type Label Description stream_name string Name of the stream (completely optional). This may be used for, e.g., topic names in a pub/sub system. stream_type RdfStreamType Type of the stream (required) generalized_statements bool Whether the stream may contain generalized triples, quads, or datasets use_repeat bool Whether RdfRepeat will be used rdf_star bool Whether the stream may contain RDF-star statements max_name_table_size uint32 Prefix tables max_prefix_table_size uint32 max_datatype_table_size uint32"},{"location":"specification/reference/#rdfstreamrow","title":"RdfStreamRow","text":"<p>=== Streams ===</p> Field Type Label Description options RdfStreamOptions triple RdfTriple RDF triple statement. Valid in TRIPLES and GRAPHS streams. quad RdfQuad RDF quad statement. Only valid in a QUADS stream. graph_start RdfGraphStart Graph boundary: ends the currently transmitted graph and starts a new one Only valid in a GRAPHS stream. graph_end RdfGraphEnd Explicit end of a graph. Signals the consumer that the transmitted graph is complete. name RdfNameEntry prefix RdfPrefixEntry datatype RdfDatatypeEntry <p></p>"},{"location":"specification/reference/#rdfterm","title":"RdfTerm","text":"Field Type Label Description iri RdfIri bnode string literal RdfLiteral triple_term RdfTriple repeat RdfRepeat"},{"location":"specification/reference/#rdftriple","title":"RdfTriple","text":"<p>=== Triples, quads, graphs ===</p> Field Type Label Description s RdfTerm p RdfTerm o RdfTerm <p></p>"},{"location":"specification/reference/#rdfstreamtype","title":"RdfStreamType","text":"Name Number Description RDF_STREAM_TYPE_UNSPECIFIED 0 RDF_STREAM_TYPE_TRIPLES 1 RDF_STREAM_TYPE_QUADS 2 RDF_STREAM_TYPE_GRAPHS 3"},{"location":"specification/reference/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"specification/serialization/","title":"Jelly serialization format","text":"<p>TODO: intro, reference to RDF 1.1 and RDF-star, link to the proto reference, status of this spec</p> <p>Info</p> <p>The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.</p> <p>Note</p> <p>The \"Note\" blocks in this document are not part of the specification, but rather provide additional information for implementers.</p>"},{"location":"specification/serialization/#conformance","title":"Conformance","text":"<p>Implementations MAY choose to implement only a subset of the following specification. In this case, they SHOULD clearly specify which parts of the specification they implement. In the rest of this specification, the keywords \"MUST\", \"MUST NOT\", etc. refer to full (not partial) implementations.</p> <p>Note</p> <p>Implementations may in particular choose to not implement features that are not supported on the target platform (e.g., RDF datasets, RDF-star, generalized RDF terms, etc.).</p> <p>Implementations MAY also choose to extend Jelly with additional features that SHOULD NOT interfere with the serialization being readable by implementations which follow the specification.</p>"},{"location":"specification/serialization/#versioning","title":"Versioning","text":"<p>The protocol follows the Semantic Versioning 2.0 scheme. </p> <p>Note</p> <p>Releases of the protocol are published on GitHub.</p>"},{"location":"specification/serialization/#backward-compatibility","title":"Backward compatibility","text":"<p>Implementations SHOULD ensure backward compatibility. To achieve backward compatibility, the implementation MUST be able to read all messages from the previous releases of the protocol with the same MAJOR version. The implementation MAY also be able to read messages from previous releases of the protocol with a different MAJOR version.</p> <p>Note</p> <p>The protocol is designed in such a way that you don't need to worry about backward compatibility. The only thing you need to do is to implement the latest version of the protocol, and you will automatically get backward compatibility with all previous versions (of the same MAJOR).</p>"},{"location":"specification/serialization/#forward-compatibility","title":"Forward compatibility","text":"<p>Forward compatibility is not guaranteed. Implementations MAY be able to read messages from future releases of the protocol with the same MAJOR version. Implementations MAY also be able to read messages from future releases of the protocol with a different MAJOR version.</p>"},{"location":"specification/serialization/#format-specification","title":"Format specification","text":"<p>The Jelly serialization format uses Protocol Buffers version 3 as the underlying serialization format. All implementations MUST use a compliant Protocol Buffers implementation. The Protocol Buffers schema for Jelly serialization is defined in <code>rdf.proto</code> (source code, reference).</p> <p>The Jelly format is a stream (i.e., an ordered sequence) of stream frames. The frames may be sent one-by-one using a dedicated streaming protocol (e.g., gRPC, MQTT, Kafka) or written in sequence to a byte stream (e.g., a file or socket). When writing to a byte stream, the frames MUST be delimeted \u2013 see the delimited variant.</p> <p>Jelly supports several distinct types of streams, and uses a simple and configurable compression mechanism using lookup tables.</p>"},{"location":"specification/serialization/#stream-frames","title":"Stream frames","text":"<p>A stream frame is a message of type <code>RdfStreamFrame</code> (reference). The message has only one field (<code>rows</code>), which is a repeated field of type <code>RdfStreamRow</code> (reference). A stream frame may contain any number of rows, however it is RECOMMENDED to keep the size of the frames below 1 MB. The semantics for the frames are not defined by the protocol. The end users are free to define their own semantics for the frames.</p> <p>Note</p> <p>A stream frame in \"simple flat file\" is just a batch of RDF statements \u2013 the stream frames may carry no semantics in this case. You can make the stream frame as long as the file itself, but this is not recommended, as it would make the file harder to process.</p> <p>Note</p> <p>Stream frames can also be used to indicate individual stream elements. For example, in the case of a stream of RDF datasets, each frame may contain one dataset. RiverBench datasets use this convention in their distributions.</p>"},{"location":"specification/serialization/#ordering","title":"Ordering","text":"<p>Stream frames MUST be processed strictly in order to preserve the semantics of the stream.</p> <p>Implementations MAY choose to adopt a non-standard solution where the order of the frames is not guaranteed and the stream can be read in more than one order. The implementation MUST clearly specify in the documentation that it uses such a non-standard solution.</p> <p>Note</p> <p>An example where not adhering to the strict ordering may be useful is when you are dealing with a network streaming protocol that does not guarantee the order of the messages (e.g., MQTT).</p> <p>Note</p> <p>The main thing you will need to worry about is the order of the lookup tables. If you can, emit all lookup tables at the beginning of the stream. When using stream partitions (e.g., in Kafka), you should ensure that the lookups are emitted to each partition. Alternatively, you can transmit the lookup tables separately from the stream.</p>"},{"location":"specification/serialization/#stream-rows","title":"Stream rows","text":"<p>A stream row is a message of type <code>RdfStreamRow</code>. It has one of the following fields set:</p> <ul> <li><code>options</code> (1) \u2013 stream options header, indicating the compression options and the used RDF features in the stream.</li> <li><code>triple</code> (2) \u2013 RDF triple statement. It MUST NOT appear in streams of type other than <code>RDF_STREAM_TYPE_TRIPLES</code> or <code>RDF_STREAM_TYPE_GRAPHS</code>.</li> <li><code>quad</code> (3) \u2013 RDF quad statement. It MUST NOT appear in streams of type other than <code>RDF_STREAM_TYPE_QUADS</code>.</li> <li><code>graph_start</code> (4) \u2013 indicates the start of a graph (named or default). It MUST NOT appear in streams of type other than <code>RDF_STREAM_TYPE_GRAPHS</code>.</li> <li><code>graph_end</code> (5) \u2013 indicates the end of a graph (named or default). It MUST NOT appear in streams of type other than <code>RDF_STREAM_TYPE_GRAPHS</code>.</li> <li><code>name</code> (9) \u2013 entry in the name lookup.</li> <li><code>prefix</code> (10) \u2013 entry in the prefix lookup.</li> <li><code>datatype</code> (11) \u2013 entry in the datatype lookup.</li> </ul> <p>Stream rows MUST be processed strictly in order to preserve the semantics of the stream.</p>"},{"location":"specification/serialization/#stream-types","title":"Stream types","text":"<p>The type of the stream MUST be explicitly specified in the (stream options header)[#stream-options]. The type of the stream is defined by the <code>RdfStreamType</code> enum (reference). The following types are defined:</p> <ul> <li><code>RDF_STREAM_TYPE_UNSPECIFIED</code> (0) \u2013 default value. This stream type MUST NOT be used. The implementations SHOULD treat this value as an error.</li> <li><code>RDF_STREAM_TYPE_TRIPLES</code> (1) \u2013 stream of RDF triple statements. Each stream frame (or the entire stream) corresponds to an RDF graph. In this case, the stream MUST NOT contain <code>RdfStreamRow</code> messages with the <code>quad</code>, <code>graph_start</code>, or <code>graph_end</code> fields set.</li> <li><code>RDF_STREAM_TYPE_QUADS</code> (2) \u2013 stream of RDF quad statements (same as simple statements in N-Quads). Each stream frame (or the entire stream) corresponds to an RDF dataset. In this case, the stream MUST NOT contain <code>RdfStreamRow</code> messages with the <code>triple</code>, <code>graph_start</code>, or <code>graph_end</code> fields set.</li> <li><code>RDF_STREAM_TYPE_GRAPHS</code> (3) \u2013 stream of RDF graphs (named or default). Each stream frame (or the entire stream) corresponds to an RDF dataset. In this case, the stream MUST NOT contain <code>RdfStreamRow</code> messages with the <code>quad</code> fields set.</li> </ul> <p>Note</p> <p>See also a more human explanation of the available stream types.</p>"},{"location":"specification/serialization/#stream-options","title":"Stream options","text":"<p>The stream options is a message of type <code>RdfStreamOptions</code> (reference). It MUST be the first row in the stream. It MAY appear more than once in the stream (also after other rows), but it MUST be identical to all previous occurrences. Implementations MAY throw an error if the stream options header is not present at the start of the stream, alternatively, they MAY use the default options. Implementations SHOULD NOT throw an error if the stream options header is present more than once in the stream.</p> <p>The stream options header instructs the consumer of the stream (parser) on the size of the needed lookups to decode the stream and the features used by the stream.</p> <p>The stream options header contains the following fields:</p> <ul> <li><code>stream_name</code> (1) \u2013 name of the stream. This field is OPTIONAL and its use is not defined by the protocol. It MAY be used to identify the stream.</li> <li><code>stream_type</code> (2) \u2013 type of the stream. This field is REQUIRED.</li> <li><code>generalized_statements</code> (3) \u2013 whether the stream contains generalized RDF triples or graphs. This field MUST be set to true if the stream contains generalized RDF triples or graphs. It SHOULD NOT be set to true if the stream does not use this feature. This field is OPTIONAL and defaults to false.</li> <li><code>use_repeat</code> (4) \u2013 whether the stream uses repeated terms compression. This field MUST be set to true if the stream uses repeated terms. It SHOULD NOT be set to true if the stream does not use this feature. This field is OPTIONAL and defaults to false.</li> <li><code>rdf_star</code> (5) \u2013 whether the stream uses RDF-star (quoted triples). This field MUST be set to true if the stream uses RDF-star. It SHOULD NOT be set to true if the stream does not use this feature. This field is OPTIONAL and defaults to false.</li> <li><code>max_name_table_size</code> (9) \u2013 maximum size of the name lookup. This field is OPTIONAL and defaults to 0 (no lookup). If the field is set to 0, the name lookup MUST NOT be used in the stream. If the field is set to a positive value, the name lookup SHOULD be used and the size of the lookup MUST NOT exceed the value of this field.</li> <li><code>max_prefix_table_size</code> (10) \u2013 maximum size of the prefix lookup. This field is OPTIONAL and defaults to 0 (no lookup). If the field is set to 0, the prefix lookup MUST NOT be used in the stream. If the field is set to a positive value, the prefix lookup SHOULD be used and the size of the lookup MUST NOT exceed the value of this field.</li> <li><code>max_datatype_table_size</code> (11) \u2013 maximum size of the datatype lookup. This field is OPTIONAL and defaults to 0 (no lookup). If the field is set to 0, the datatype lookup MUST NOT be used in the stream (which effectively prohibits the use of datatype literals). If the field is set to a positive value, the datatype lookup SHOULD be used and the size of the lookup MUST NOT exceed the value of this field.</li> </ul>"},{"location":"specification/serialization/#prefix-name-and-datatype-lookups","title":"Prefix, name, and datatype lookups","text":"<p>TODO</p>"},{"location":"specification/serialization/#rdf-statements-and-graphs","title":"RDF statements and graphs","text":""},{"location":"specification/serialization/#rdf-terms","title":"RDF terms","text":""},{"location":"specification/serialization/#iris","title":"IRIs","text":""},{"location":"specification/serialization/#blank-nodes","title":"Blank nodes","text":""},{"location":"specification/serialization/#literals","title":"Literals","text":""},{"location":"specification/serialization/#quoted-triples-rdf-star","title":"Quoted triples (RDF-star)","text":""},{"location":"specification/serialization/#repeated-terms","title":"Repeated terms","text":""},{"location":"specification/serialization/#rdf-graph-nodes","title":"RDF graph nodes","text":""},{"location":"specification/serialization/#delimited-variant-of-jelly","title":"Delimited variant of Jelly","text":"<p>Note</p> <p>Protobuf messages are not delimited, so if you write multiple messages to the same file / socket / byte stream, you need to add some kind of delimiter between them. Jelly uses the convention already implemented in some protobuf libraries of prepending a varint before the message, to specify the length of the message. </p> <p>A byte stream (or file) in the delimited variant MUST consist of a series of delimited <code>RdfStreamFrame</code> messages. A delimited message is a message that has a varint prepended before it, specifying the length of the message.</p> <p>Implementing the delimited variant is OPTIONAL.</p>"},{"location":"specification/serialization/#implementations","title":"Implementations","text":"<p>The delimiting convention is implemented in:</p> <ul> <li>C++: delimited_message_util.cc</li> <li>Java / Scala: writeDelimitedTo and parseDelimitedFrom</li> </ul> <p>The JVM (Scala) implementation of Jelly also supports the delimited variant \u2013 see the documentation.</p>"}]}