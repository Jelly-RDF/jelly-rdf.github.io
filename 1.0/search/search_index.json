{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Test \u2013 index.md</p>"},{"location":"contributing/","title":"Contributing","text":"<p>TODO</p>"},{"location":"licensing/","title":"Licensing and citation","text":"<p>TODO</p>"},{"location":"jvm/","title":"Jelly JVM (Scala) implementation","text":""},{"location":"jvm/grpc/","title":"User guide \u2013 gRPC","text":""},{"location":"jvm/grpc/#example-grpc-pubsub","title":"Example \u2013 gRPC pub/sub","text":""},{"location":"jvm/implementation/","title":"Developer guide \u2013 implementing conversions for other libraries","text":"<p>Currently converters for the two most popular RDF JVM libraries are implemented \u2013 RDF4J and Jena. But it is possible to implement your own converters and adapt the Jelly serialization code to any RDF library with little effort.</p> <p>To do this, you will need to implement three traits (interfaces in Java) from the <code>jelly-core</code> module: <code>ProtoEncoder</code>, <code>ProtoDecoderConverter</code>, and <code>ConverterFactory</code>.</p> <ul> <li>ProtoEncoder (serialization)</li> <li><code>get*</code> methods deconstruct triple statements, quad statements, and quoted triples (RDF-star). You can make them <code>inline</code>.</li> <li><code>nodeToProto</code> and <code>graphToProto</code> should translate into Jelly's representation all possible variations of RDF terms in the SPO and G positions, respectively.</li> <li>Example implementation for Jena: JenaProtoEncoder</li> <li>You can skip implementing this trait if you don't need serialization.</li> <li> <p>You can also skip implementing some methods (make them throw an exception or return null) if, for example, you don't want to work with quads or RDF-start.</p> </li> <li> <p>ProtoDecoderConverter (deserialization)</p> </li> <li>The <code>make*</code> methods should construct new RDF terms and statements. You can make them <code>inline</code>.</li> <li>Example implementation for Jena: JenaDecoderConverter</li> <li>You can skip implementing this trait if you don't need deserialization.</li> <li> <p>You can also skip implementing some methods (make them throw an exception or return null) if, for example, you don't want to work with quads or RDF-start.</p> </li> <li> <p>ConverterFactory \u2013 wrapper that allows other modules to use your converter.</p> </li> <li>The methods should just return new instances of your <code>ProtoEncoder</code> and <code>ProtoDecoderConverter</code> implementations.</li> <li>Example for Jena: JenaConverterFactory</li> </ul>"},{"location":"jvm/reactive/","title":"User guide \u2013 reactive streaming","text":"<p>TODO</p>"},{"location":"jvm/reactive/#example-streaming-with-kafka","title":"Example: streaming with Kafka","text":""},{"location":"jvm/reactive/#byte-streams","title":"Byte streams","text":"<p>TODO</p> <p>(referenced by specification/serialization.md)</p>"},{"location":"jvm/releases/","title":"Developer guide \u2013 releases","text":""},{"location":"jvm/releases/#full-versioned-releases","title":"Full (versioned) releases","text":"<p>Full (versioned) releases are created manually and follow the Semantic Versioning scheme for binary compatibility.</p> <p>To create a new tagged release (example for version 1.2.3): <pre><code>$ git checkout main\n$ git pull\n$ git tag v1.2.3\n$ git push origin v1.2.3\n</code></pre></p> <p>The rest (packaging and release creation) will be handled automatically by the CI. The release will be pushed to Maven Central.</p>"},{"location":"jvm/releases/#snapshot-releases","title":"Snapshot releases","text":"<p>Snapshot releases are triggered automatically by commits in the <code>main</code> branch. Snapshots are pushed to the Sonatype snapshot repository.</p>"},{"location":"specification/","title":"Protocol specification","text":"<p>TODO</p>"},{"location":"specification/media-type/","title":"File extension and media type","text":"<p>Jelly is not tied to any specific file extension and does not have a registered media type. However, you can use the following:</p> <ul> <li>File extension: <code>.jelly</code></li> <li>Media type: <code>application/x-jelly-rdf</code></li> </ul> <p>The files should be saved in the delimited variant of Jelly.</p>"},{"location":"specification/media-type/#see-also","title":"See also","text":"<ul> <li>Serialization format specification</li> </ul>"},{"location":"specification/reference/","title":"Protocol Documentation","text":""},{"location":"specification/reference/#table-of-contents","title":"Table of Contents","text":"<ul> <li> <p>grpc.proto</p> <ul> <li>RdfStreamReceived</li> <li> <p>RdfStreamSubscribe</p> </li> <li> <p>RdfStreamService</p> </li> </ul> </li> <li> <p>rdf.proto</p> <ul> <li>RdfDatatypeEntry</li> <li>RdfDefaultGraph</li> <li>RdfGraph</li> <li>RdfGraphEnd</li> <li>RdfGraphStart</li> <li>RdfIri</li> <li>RdfLiteral</li> <li>RdfLiteralSimple</li> <li>RdfNameEntry</li> <li>RdfPrefixEntry</li> <li>RdfQuad</li> <li>RdfRepeat</li> <li>RdfStreamFrame</li> <li>RdfStreamOptions</li> <li>RdfStreamRow</li> <li>RdfTerm</li> <li> <p>RdfTriple</p> </li> <li> <p>RdfStreamType</p> </li> </ul> </li> <li> <p>Scalar Value Types</p> </li> </ul> <p></p> <p>Top</p>"},{"location":"specification/reference/#grpcproto","title":"grpc.proto","text":""},{"location":"specification/reference/#rdfstreamreceived","title":"RdfStreamReceived","text":""},{"location":"specification/reference/#rdfstreamsubscribe","title":"RdfStreamSubscribe","text":"<p>=== Pub/Sub ===</p> Field Type Label Description topic string The topic to which the client wants to subscribe. requested_options RdfStreamOptions Optional: the stream options requested by the client. The server should respond with a stream that matches these options. In case that is not possible, the server must respond with the INVALID_ARGUMENT error. <p></p>"},{"location":"specification/reference/#rdfstreamservice","title":"RdfStreamService","text":"Method Name Request Type Response Type Description SubscribeRdf RdfStreamSubscribe RdfStreamFrame stream PublishRdf RdfStreamFrame stream RdfStreamReceived <p>Top</p>"},{"location":"specification/reference/#rdfproto","title":"rdf.proto","text":""},{"location":"specification/reference/#rdfdatatypeentry","title":"RdfDatatypeEntry","text":"Field Type Label Description id uint32 1-based value string"},{"location":"specification/reference/#rdfdefaultgraph","title":"RdfDefaultGraph","text":""},{"location":"specification/reference/#rdfgraph","title":"RdfGraph","text":"Field Type Label Description iri RdfIri bnode string literal RdfLiteral default_graph RdfDefaultGraph repeat RdfRepeat Only valid in a QUADS stream."},{"location":"specification/reference/#rdfgraphend","title":"RdfGraphEnd","text":""},{"location":"specification/reference/#rdfgraphstart","title":"RdfGraphStart","text":"Field Type Label Description graph RdfGraph"},{"location":"specification/reference/#rdfiri","title":"RdfIri","text":"<p>=== Rdf Terms ===</p> Field Type Label Description prefix_id uint32 Either of these can be zero if the prefix or the suffix are not used. name_id uint32 <p></p>"},{"location":"specification/reference/#rdfliteral","title":"RdfLiteral","text":"Field Type Label Description lex string simple RdfLiteralSimple langtag string datatype uint32"},{"location":"specification/reference/#rdfliteralsimple","title":"RdfLiteralSimple","text":""},{"location":"specification/reference/#rdfnameentry","title":"RdfNameEntry","text":"Field Type Label Description id uint32 1-based value string"},{"location":"specification/reference/#rdfprefixentry","title":"RdfPrefixEntry","text":"Field Type Label Description id uint32 1-based value string"},{"location":"specification/reference/#rdfquad","title":"RdfQuad","text":"Field Type Label Description s RdfTerm p RdfTerm o RdfTerm g RdfGraph"},{"location":"specification/reference/#rdfrepeat","title":"RdfRepeat","text":""},{"location":"specification/reference/#rdfstreamframe","title":"RdfStreamFrame","text":"Field Type Label Description rows RdfStreamRow repeated"},{"location":"specification/reference/#rdfstreamoptions","title":"RdfStreamOptions","text":"Field Type Label Description stream_name string Name of the stream (completely optional). This may be used for, e.g., topic names in a pub/sub system. stream_type RdfStreamType Type of the stream (required) generalized_statements bool Whether the stream may contain generalized triples, quads, or datasets use_repeat bool Whether RdfRepeat will be used rdf_star bool Whether the stream may contain RDF-star statements max_name_table_size uint32 Prefix tables max_prefix_table_size uint32 max_datatype_table_size uint32"},{"location":"specification/reference/#rdfstreamrow","title":"RdfStreamRow","text":"<p>=== Streams ===</p> Field Type Label Description options RdfStreamOptions triple RdfTriple RDF triple statement. Valid in TRIPLES and GRAPHS streams. quad RdfQuad RDF quad statement. Only valid in a QUADS stream. graph_start RdfGraphStart Graph boundary: ends the currently transmitted graph and starts a new one Only valid in a GRAPHS stream. graph_end RdfGraphEnd Explicit end of a graph. Signals the consumer that the transmitted graph is complete. name RdfNameEntry prefix RdfPrefixEntry datatype RdfDatatypeEntry <p></p>"},{"location":"specification/reference/#rdfterm","title":"RdfTerm","text":"Field Type Label Description iri RdfIri bnode string literal RdfLiteral triple_term RdfTriple repeat RdfRepeat"},{"location":"specification/reference/#rdftriple","title":"RdfTriple","text":"<p>=== Triples, quads, graphs ===</p> Field Type Label Description s RdfTerm p RdfTerm o RdfTerm <p></p>"},{"location":"specification/reference/#rdfstreamtype","title":"RdfStreamType","text":"Name Number Description RDF_STREAM_TYPE_UNSPECIFIED 0 RDF_STREAM_TYPE_TRIPLES 1 RDF_STREAM_TYPE_QUADS 2 RDF_STREAM_TYPE_GRAPHS 3"},{"location":"specification/reference/#scalar-value-types","title":"Scalar Value Types","text":".proto Type Notes C++ Java Python Go C# PHP Ruby  double double double float float64 double float Float  float float float float float32 float float Float  int32 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint32 instead. int32 int int int32 int integer Bignum or Fixnum (as required)  int64 Uses variable-length encoding. Inefficient for encoding negative numbers \u2013 if your field is likely to have negative values, use sint64 instead. int64 long int/long int64 long integer/string Bignum  uint32 Uses variable-length encoding. uint32 int int/long uint32 uint integer Bignum or Fixnum (as required)  uint64 Uses variable-length encoding. uint64 long int/long uint64 ulong integer/string Bignum or Fixnum (as required)  sint32 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int32s. int32 int int int32 int integer Bignum or Fixnum (as required)  sint64 Uses variable-length encoding. Signed int value. These more efficiently encode negative numbers than regular int64s. int64 long int/long int64 long integer/string Bignum  fixed32 Always four bytes. More efficient than uint32 if values are often greater than 2^28. uint32 int int uint32 uint integer Bignum or Fixnum (as required)  fixed64 Always eight bytes. More efficient than uint64 if values are often greater than 2^56. uint64 long int/long uint64 ulong integer/string Bignum  sfixed32 Always four bytes. int32 int int int32 int integer Bignum or Fixnum (as required)  sfixed64 Always eight bytes. int64 long int/long int64 long integer/string Bignum  bool bool boolean boolean bool bool boolean TrueClass/FalseClass  string A string must always contain UTF-8 encoded or 7-bit ASCII text. string String str/unicode string string string String (UTF-8)  bytes May contain any arbitrary sequence of bytes. string ByteString str []byte ByteString string String (ASCII-8BIT)"},{"location":"specification/serialization/","title":"Jelly serialization format","text":"<p>TODO: intro, reference to RDF 1.1 and RDF-star</p> <p>Info</p> <p>The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119.</p>"},{"location":"specification/serialization/#format-specification","title":"Format specification","text":"<p>TODO: overall structure, stream frames and rows, mention lookup tables, multiple types</p>"},{"location":"specification/serialization/#stream-options","title":"Stream options","text":"<p>TODO</p>"},{"location":"specification/serialization/#stream-types","title":"Stream types","text":"<p>TODO</p>"},{"location":"specification/serialization/#prefix-name-and-datatype-lookups","title":"Prefix, name, and datatype lookups","text":"<p>TODO</p>"},{"location":"specification/serialization/#rdf-statements","title":"RDF statements","text":""},{"location":"specification/serialization/#rdf-terms","title":"RDF terms","text":""},{"location":"specification/serialization/#iris","title":"IRIs","text":""},{"location":"specification/serialization/#blank-nodes","title":"Blank nodes","text":""},{"location":"specification/serialization/#literals","title":"Literals","text":""},{"location":"specification/serialization/#quoted-triples-rdf-star","title":"Quoted triples (RDF-star)","text":""},{"location":"specification/serialization/#repeated-terms","title":"Repeated terms","text":""},{"location":"specification/serialization/#rdf-graph-nodes","title":"RDF graph nodes","text":""},{"location":"specification/serialization/#delimited-variant","title":"Delimited variant","text":"<p>Note</p> <p>Protobuf messages are not delimited, so if you write multiple messages to the same file / socket / byte stream, you need to add some kind of delimiter between them. Jelly uses the convention already implemented in some protobuf libraries of prepending a varint before the message, to specify the length of the message. </p> <p>A byte stream (or file) in the delimited variant MUST consist of a series of delimited <code>RdfStreamFrame</code> messages. A delimited message is a message that has a varint prepended before it, specifying the length of the message.</p> <p>Implementing the delimited variant is OPTIONAL.</p>"},{"location":"specification/serialization/#implementations","title":"Implementations","text":"<p>The delimiting convention is implemented in:</p> <ul> <li>C++: delimited_message_util.cc</li> <li>Java / Scala: writeDelimitedTo and parseDelimitedFrom</li> </ul> <p>The JVM (Scala) implementation of Jelly also supports the delimited variant \u2013 see the documentation.</p>"}]}